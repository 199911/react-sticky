(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Sticky = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = (typeof window !== "undefined" ? window['React'] : typeof global !== "undefined" ? global['React'] : null);

var _react2 = _interopRequireDefault(_react);

var _sticky = require('./sticky');

var _sticky2 = _interopRequireDefault(_sticky);

var _utils = require('./utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Container = function (_React$Component) {
  _inherits(Container, _React$Component);

  function Container(props) {
    _classCallCheck(this, Container);

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Container).call(this, props));

    _this.state = {
      topCorrection: 0
    };
    return _this;
  }

  _createClass(Container, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.setState({ node: ReactDOM.findDOMNode(this) });
    }
  }, {
    key: 'getChildContext',
    value: function getChildContext() {
      return {
        container: this
      };
    }
  }, {
    key: 'setTopCorrection',
    value: function setTopCorrection(topCorrection) {
      this.setState({ topCorrection: topCorrection });
    }
  }, {
    key: 'render',
    value: function render() {
      var style = (0, _utils.copy)({}, this.props.style || {});

      if (this.state.node) {
        var paddingTop = style.paddingTop || parseInt(this.state.node.style.paddingTop) || 0;
        style.paddingTop = paddingTop + this.state.topCorrection;
      }

      return _react2.default.createElement(
        'div',
        _extends({}, this.props, { style: style }),
        this.props.children
      );
    }
  }]);

  return Container;
}(_react2.default.Component);

Container.contextTypes = {
  container: _react2.default.PropTypes.any
};

Container.childContextTypes = {
  container: _react2.default.PropTypes.any
};

exports.default = Container;
module.exports = exports['default'];

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./sticky":2,"./utils":3}],2:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = (typeof window !== "undefined" ? window['React'] : typeof global !== "undefined" ? global['React'] : null);

var _react2 = _interopRequireDefault(_react);

var _reactDom = (typeof window !== "undefined" ? window['ReactDOM'] : typeof global !== "undefined" ? global['ReactDOM'] : null);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _watcher = require('./watcher');

var _watcher2 = _interopRequireDefault(_watcher);

var _utils = require('./utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Sticky = function (_React$Component) {
  _inherits(Sticky, _React$Component);

  function Sticky(props) {
    _classCallCheck(this, Sticky);

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Sticky).call(this, props));

    _this.state = {};
    return _this;
  }

  /*
   * Return the distance of the scrollbar from the
   * top of the window plus the total height of all
   * stuck Sticky instances above this one.
   */


  _createClass(Sticky, [{
    key: 'pageOffset',
    value: function pageOffset() {
      return window.pageYOffset || document.documentElement.scrollTop;
    }
  }, {
    key: 'otherStickyOffset',
    value: function otherStickyOffset() {
      var offset = 0;
      if (this.container) {
        var container = this.container.context.container;
        while (container) {
          offset = container.state.topCorrection;
          container = container.context.container;
        };
      }
      return offset;
    }

    /*
     * Returns the y-coordinate of the top of this element.
     */

  }, {
    key: 'calculateOrigin',
    value: function calculateOrigin(node) {
      node = node || this.node;

      // Only recalcute origin if the last origin has been made stale via resize
      if (this.lastWidth !== window.innerWidth || this.lastHeight !== window.innerHeight) {
        this.lastWidth = window.innerWidth;
        this.lastHeight = window.innerHeight;

        // Do some ugly DOM manipulation to where this element's non-sticky position would be
        var previousPosition = node.style.position;
        node.style.position = '';
        this.origin = node.getBoundingClientRect().top + this.pageOffset() - this.otherStickyOffset();
        node.style.position = previousPosition;
      }

      return this.origin;
    }

    /*
     * Returns true/false depending on if this should be sticky.
     */

  }, {
    key: 'shouldBeSticky',
    value: function shouldBeSticky() {
      var offset = this.pageOffset();
      var origin = this.calculateOrigin();

      var stickyTopConditionsMet = offset >= origin + this.props.topOffset;
      var stickyBottomConditionsMet = offset < this.containerNode.getBoundingClientRect().height + origin - this.node.getBoundingClientRect().height;
      return stickyTopConditionsMet && stickyBottomConditionsMet;
    }
  }, {
    key: 'transition',
    value: function transition() {
      if (this.containerNode) {
        this.nextState(this.shouldBeSticky());
      }
    }

    /*
     * Anytime new props are received, force re-evaluation
     */

  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps() {
      _watcher2.default.emit();
    }
  }, {
    key: 'componentWillUpdate',
    value: function componentWillUpdate(props, state, context) {
      this.container = context.container;
      this.containerNode = _reactDom2.default.findDOMNode(this.container);
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.node = _reactDom2.default.findDOMNode(this);
      _watcher2.default.on(this.transition.bind(this));
      _watcher2.default.emit();
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      _watcher2.default.off(this.transition.bind(this));
    }

    /*
     * If sticky, merge this.props.stickyStyle with this.props.style.
     * If not, just return this.props.style.
     */

  }, {
    key: 'nextStyle',
    value: function nextStyle(shouldBeSticky) {
      if (shouldBeSticky) {
        // inherit the boundaries of the container
        var rect = (this.containerNode || document.body).getBoundingClientRect();
        var style = (0, _utils.copy)({}, this.props.style);
        style.position = 'fixed';
        style.left = rect.left;
        style.width = rect.width;
        style.top = this.otherStickyOffset();

        // Finally, override the best-fit style with any user props
        return (0, _utils.copy)(style, this.props.stickyStyle);
      } else {
        return this.props.style;
      }
    }

    /*
     * If sticky, merge this.props.stickyClass with this.props.className.
     * If not, just return this.props.className.
     */

  }, {
    key: 'nextClassName',
    value: function nextClassName(shouldBeSticky) {
      var className = this.props.className;
      if (shouldBeSticky) {
        className += ' ' + this.props.stickyClass;
      }
      return className;
    }

    /*
     * Transition to the next state.
     *
     * Updates the isSticky, style, and className state
     * variables.
     *
     * If sticky state is different than the previous,
     * fire the onStickyStateChange callback.
     */

  }, {
    key: 'nextState',
    value: function nextState(shouldBeSticky) {
      var hasChanged = this.state.isSticky !== shouldBeSticky;
      this.setState({
        isSticky: shouldBeSticky,
        style: this.nextStyle(shouldBeSticky),
        className: this.nextClassName(shouldBeSticky)
      });
      if (hasChanged) {
        this.preventBounce(shouldBeSticky);
        this.props.onStickyStateChange(shouldBeSticky);
      }
    }
  }, {
    key: 'preventBounce',
    value: function preventBounce(shouldBeSticky) {
      var bounceCorrection = undefined;
      if (shouldBeSticky) {
        bounceCorrection = this.bounceCorrection = Math.ceil(this.node.getBoundingClientRect().height);
      } else {
        bounceCorrection = -this.bounceCorrection || 0;
      }
      if (this.container) this.container.setTopCorrection(bounceCorrection);
    }

    /*
     * The special sauce.
     */

  }, {
    key: 'render',
    value: function render() {
      return _react2.default.createElement(
        'div',
        { style: this.state.style, className: this.state.className },
        this.props.children
      );
    }
  }]);

  return Sticky;
}(_react2.default.Component);

Sticky.contextTypes = {
  container: _react2.default.PropTypes.any
};

/*
 * Default properties...
 */
Sticky.defaultProps = {
  className: '',
  style: {},
  stickyClass: 'sticky',
  stickyStyle: {},
  topOffset: 0,
  onStickyStateChange: function onStickyStateChange() {}
};

exports.default = Sticky;
module.exports = exports['default'];

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./utils":3,"./watcher":4}],3:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.copy = copy;
exports.findStickies = findStickies;

var _react = (typeof window !== "undefined" ? window['React'] : typeof global !== "undefined" ? global['React'] : null);

var _sticky = require('./sticky');

var _sticky2 = _interopRequireDefault(_sticky);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function copy(dest, source) {
  for (var rule in source) {
    dest[rule] = source[rule];
  };
  return dest;
}

function findStickies(children) {
  var found = [];
  children.forEach(function (child) {
    if (child.type === _sticky2.default) found.push(child);
  });
  return found;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./sticky":2}],4:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _raf = require('raf');

var _raf2 = _interopRequireDefault(_raf);

var _simpleSignal = require('simple-signal');

var _simpleSignal2 = _interopRequireDefault(_simpleSignal);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var state = {
  hasUnhandledEvent: false,
  hasTouchEvent: false
};

var signal = new _simpleSignal2.default();

/**
  * Wire up event listeners
  */
['scroll', 'resize', 'touchmove', 'touchend'].forEach(function (evt) {
  if (window.addEventListener) {
    window.addEventListener(evt, handleEvent);
  } else {
    window.attachEvent('on' + evt, handleEvent);
  }
});

// Start the loop
(0, _raf2.default)(function tick() {
  if (state.hasUnhandledEvent || state.hasTouchEvent) {
    signal.emit();
    state.hasUnhandledEvent = false;
  }
  (0, _raf2.default)(tick);
});

function handleEvent(event) {
  switch (event.type) {
    case 'touchmove':
      state.hasTouchEvent = true;
      break;
    case 'touchend':
      state.hasTouchEvent = false;
      break;
    default:
      state.hasUnhandledEvent = true;
  }
}

exports.default = signal;
module.exports = exports['default'];

},{"raf":8,"simple-signal":9}],5:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _sticky = require('./sticky');

var _sticky2 = _interopRequireDefault(_sticky);

var _container = require('./container');

var _container2 = _interopRequireDefault(_container);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_sticky2.default.Container = _container2.default;

exports.default = _sticky2.default;
module.exports = exports['default'];

},{"./container":1,"./sticky":2}],6:[function(require,module,exports){
(function (process){
// Generated by CoffeeScript 1.7.1
(function() {
  var getNanoSeconds, hrtime, loadTime;

  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
    module.exports = function() {
      return performance.now();
    };
  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
    module.exports = function() {
      return (getNanoSeconds() - loadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    loadTime = getNanoSeconds();
  } else if (Date.now) {
    module.exports = function() {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    module.exports = function() {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }

}).call(this);

}).call(this,require('_process'))

},{"_process":7}],7:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],8:[function(require,module,exports){
(function (global){
var now = require('performance-now')
  , root = typeof window === 'undefined' ? global : window
  , vendors = ['moz', 'webkit']
  , suffix = 'AnimationFrame'
  , raf = root['request' + suffix]
  , caf = root['cancel' + suffix] || root['cancelRequest' + suffix]

for(var i = 0; !raf && i < vendors.length; i++) {
  raf = root[vendors[i] + 'Request' + suffix]
  caf = root[vendors[i] + 'Cancel' + suffix]
      || root[vendors[i] + 'CancelRequest' + suffix]
}

// Some versions of FF have rAF but not cAF
if(!raf || !caf) {
  var last = 0
    , id = 0
    , queue = []
    , frameDuration = 1000 / 60

  raf = function(callback) {
    if(queue.length === 0) {
      var _now = now()
        , next = Math.max(0, frameDuration - (_now - last))
      last = next + _now
      setTimeout(function() {
        var cp = queue.slice(0)
        // Clear queue here to prevent
        // callbacks from appending listeners
        // to the current frame's queue
        queue.length = 0
        for(var i = 0; i < cp.length; i++) {
          if(!cp[i].cancelled) {
            try{
              cp[i].callback(last)
            } catch(e) {
              setTimeout(function() { throw e }, 0)
            }
          }
        }
      }, Math.round(next))
    }
    queue.push({
      handle: ++id,
      callback: callback,
      cancelled: false
    })
    return id
  }

  caf = function(handle) {
    for(var i = 0; i < queue.length; i++) {
      if(queue[i].handle === handle) {
        queue[i].cancelled = true
      }
    }
  }
}

module.exports = function(fn) {
  // Wrap in a new function to prevent
  // `cancel` potentially being assigned
  // to the native rAF function
  return raf.call(root, fn)
}
module.exports.cancel = function() {
  caf.apply(root, arguments)
}
module.exports.polyfill = function() {
  root.requestAnimationFrame = raf
  root.cancelAnimationFrame = caf
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"performance-now":6}],9:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports["default"] = Signal;

function Signal() {
  var subscribers = [];
  return {
    on: function on(fn) {
      subscribers.push(fn);
    },
    off: function off(fn) {
      var index = subscribers.indexOf(fn);
      if (index > -1) {
        subscribers.splice(index, 1);
      }
    },
    emit: function emit(val) {
      for (var i = 0, len = subscribers.length; i < len; ++i) {
        subscribers[i](val);
      }
    }
  };
}

module.exports = exports["default"];
},{}]},{},[5])(5)
});
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJsaWIvY29udGFpbmVyLmpzIiwibGliL3N0aWNreS5qcyIsImxpYi91dGlscy5qcyIsImxpYi93YXRjaGVyLmpzIiwiaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGVyZm9ybWFuY2Utbm93L2xpYi9wZXJmb3JtYW5jZS1ub3cuanMiLCJub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JhZi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zaW1wbGUtc2lnbmFsL2xpYi9pbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lDSU07OztBQUNKLFdBREksU0FDSixDQUFZLEtBQVosRUFBbUI7MEJBRGYsV0FDZTs7dUVBRGYsc0JBRUksUUFEVzs7QUFFakIsVUFBSyxLQUFMLEdBQWE7QUFDWCxxQkFBZSxDQUFmO0tBREYsQ0FGaUI7O0dBQW5COztlQURJOzt3Q0FRZ0I7QUFDbEIsV0FBSyxRQUFMLENBQWMsRUFBRSxNQUFNLFNBQVMsV0FBVCxDQUFxQixJQUFyQixDQUFOLEVBQWhCLEVBRGtCOzs7O3NDQUlGO0FBQ2hCLGFBQU87QUFDTCxtQkFBVyxJQUFYO09BREYsQ0FEZ0I7Ozs7cUNBTUQsZUFBZTtBQUM5QixXQUFLLFFBQUwsQ0FBYyxFQUFFLDRCQUFGLEVBQWQsRUFEOEI7Ozs7NkJBSXZCO0FBQ1AsVUFBSSxRQUFRLGlCQUFLLEVBQUwsRUFBUyxLQUFLLEtBQUwsQ0FBVyxLQUFYLElBQW9CLEVBQXBCLENBQWpCLENBREc7O0FBR1AsVUFBSSxLQUFLLEtBQUwsQ0FBVyxJQUFYLEVBQWlCO0FBQ25CLFlBQUksYUFBYSxNQUFNLFVBQU4sSUFBcUIsU0FBUyxLQUFLLEtBQUwsQ0FBVyxJQUFYLENBQWdCLEtBQWhCLENBQXNCLFVBQXRCLENBQVQsSUFBOEMsQ0FBOUMsQ0FEbkI7QUFFbkIs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O0FBRUUsWUFGRjtBQURGLFNBSU8sVUFBTDtBQUNFLFlBQU0sYUFBTixHQUFzQixLQUF0QixDQURGO0FBRUUsWUFGRjtBQUpGO0FBUUksWUFBTSxpQkFBTixHQUEwQixJQUExQixDQURGO0FBUEYsR0FEMEI7Q0FBNUI7O2tCQWFlOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzFDZixpQkFBTyxTQUFQOzs7Ozs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgU3RpY2t5IGZyb20gJy4vc3RpY2t5JztcbmltcG9ydCB7IGNvcHkgfSBmcm9tICcuL3V0aWxzJztcblxuY2xhc3MgQ29udGFpbmVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHRvcENvcnJlY3Rpb246IDBcbiAgICB9O1xuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IG5vZGU6IFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpIH0pO1xuICB9XG5cbiAgZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb250YWluZXI6IHRoaXNcbiAgICB9XG4gIH1cblxuICBzZXRUb3BDb3JyZWN0aW9uKHRvcENvcnJlY3Rpb24pIHtcbiAgICB0aGlzLnNldFN0YXRlKHsgdG9wQ29ycmVjdGlvbiB9KTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBsZXQgc3R5bGUgPSBjb3B5KHt9LCB0aGlzLnByb3BzLnN0eWxlIHx8IHt9KTtcblxuICAgIGlmICh0aGlzLnN0YXRlLm5vZGUpIHtcbiAgICAgIGxldCBwYWRkaW5nVG9wID0gc3R5bGUucGFkZGluZ1RvcCB8fCAocGFyc2VJbnQodGhpcy5zdGF0ZS5ub2RlLnN0eWxlLnBhZGRpbmdUb3ApIHx8IDApO1xuICAgICAgc3R5bGUucGFkZGluZ1RvcCA9IHBhZGRpbmdUb3AgKyB0aGlzLnN0YXRlLnRvcENvcnJlY3Rpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIDxkaXYgey4uLnRoaXMucHJvcHN9IHN0eWxlPXtzdHlsZX0+XG4gICAgICB7dGhpcy5wcm9wcy5jaGlsZHJlbn1cbiAgICA8L2Rpdj5cbiAgfVxufVxuXG5Db250YWluZXIuY29udGV4dFR5cGVzID0ge1xuICBjb250YWluZXI6IFJlYWN0LlByb3BUeXBlcy5hbnlcbn1cblxuQ29udGFpbmVyLmNoaWxkQ29udGV4dFR5cGVzID0ge1xuICBjb250YWluZXI6IFJlYWN0LlByb3BUeXBlcy5hbnlcbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29udGFpbmVyO1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IHdhdGNoZXIgZnJvbSAnLi93YXRjaGVyJztcbmltcG9ydCB7IGNvcHkgfSBmcm9tICcuL3V0aWxzJztcblxuY2xhc3MgU3RpY2t5IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblxuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0geyB9O1xuICB9XG5cbiAgLypcbiAgICogUmV0dXJuIHRoZSBkaXN0YW5jZSBvZiB0aGUgc2Nyb2xsYmFyIGZyb20gdGhlXG4gICAqIHRvcCBvZiB0aGUgd2luZG93IHBsdXMgdGhlIHRvdGFsIGhlaWdodCBvZiBhbGxcbiAgICogc3R1Y2sgU3RpY2t5IGluc3RhbmNlcyBhYm92ZSB0aGlzIG9uZS5cbiAgICovXG4gIHBhZ2VPZmZzZXQoKSB7XG4gICAgcmV0dXJuICh3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCk7XG4gIH1cblxuICBvdGhlclN0aWNreU9mZnNldCgpIHtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBpZiAodGhpcy5jb250YWluZXIpIHtcbiAgICAgIGxldCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lci5jb250ZXh0LmNvbnRhaW5lcjtcbiAgICAgIHdoaWxlIChjb250YWluZXIpIHtcbiAgICAgICAgb2Zmc2V0ID0gY29udGFpbmVyLnN0YXRlLnRvcENvcnJlY3Rpb247XG4gICAgICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lci5jb250ZXh0LmNvbnRhaW5lcjtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQ7XG4gIH1cblxuICAvKlxuICAgKiBSZXR1cm5zIHRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIHRvcCBvZiB0aGlzIGVsZW1lbnQuXG4gICAqL1xuICBjYWxjdWxhdGVPcmlnaW4obm9kZSkge1xuICAgIG5vZGUgPSBub2RlIHx8IHRoaXMubm9kZTtcblxuICAgIC8vIE9ubHkgcmVjYWxjdXRlIG9yaWdpbiBpZiB0aGUgbGFzdCBvcmlnaW4gaGFzIGJlZW4gbWFkZSBzdGFsZSB2aWEgcmVzaXplXG4gICAgaWYgKHRoaXMubGFzdFdpZHRoICE9PSB3aW5kb3cuaW5uZXJXaWR0aCB8fCB0aGlzLmxhc3RIZWlnaHQgIT09IHdpbmRvdy5pbm5lckhlaWdodCkge1xuICAgICAgdGhpcy5sYXN0V2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgIHRoaXMubGFzdEhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcblxuICAgICAgLy8gRG8gc29tZSB1Z2x5IERPTSBtYW5pcHVsYXRpb24gdG8gd2hlcmUgdGhpcyBlbGVtZW50J3Mgbm9uLXN0aWNreSBwb3NpdGlvbiB3b3VsZCBiZVxuICAgICAgbGV0IHByZXZpb3VzUG9zaXRpb24gPSBub2RlLnN0eWxlLnBvc2l0aW9uO1xuICAgICAgbm9kZS5zdHlsZS5wb3NpdGlvbiA9ICcnO1xuICAgICAgdGhpcy5vcmlnaW4gPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCArIHRoaXMucGFnZU9mZnNldCgpIC0gdGhpcy5vdGhlclN0aWNreU9mZnNldCgpO1xuICAgICAgbm9kZS5zdHlsZS5wb3NpdGlvbiA9IHByZXZpb3VzUG9zaXRpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMub3JpZ2luO1xuICB9XG5cbiAgLypcbiAgICogUmV0dXJucyB0cnVlL2ZhbHNlIGRlcGVuZGluZyBvbiBpZiB0aGlzIHNob3VsZCBiZSBzdGlja3kuXG4gICAqL1xuICBzaG91bGRCZVN0aWNreSgpIHtcbiAgICBsZXQgb2Zmc2V0ID0gdGhpcy5wYWdlT2Zmc2V0KCk7XG4gICAgbGV0IG9yaWdpbiA9IHRoaXMuY2FsY3VsYXRlT3JpZ2luKCk7XG5cbiAgICB2YXIgc3RpY2t5VG9wQ29uZGl0aW9uc01ldCA9IG9mZnNldCA+PSBvcmlnaW4gKyB0aGlzLnByb3BzLnRvcE9mZnNldDtcbiAgICB2YXIgc3RpY2t5Qm90dG9tQ29uZGl0aW9uc01ldCA9IG9mZnNldCA8IHRoaXMuY29udGFpbmVyTm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQgKyBvcmlnaW4gLSB0aGlzLm5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuICAgIHJldHVybiBzdGlja3lUb3BDb25kaXRpb25zTWV0ICYmIHN0aWNreUJvdHRvbUNvbmRpdGlvbnNNZXQ7XG4gIH1cblxuXG4gIHRyYW5zaXRpb24oKSB7XG4gICAgaWYgKHRoaXMuY29udGFpbmVyTm9kZSkge1xuICAgICAgdGhpcy5uZXh0U3RhdGUodGhpcy5zaG91bGRCZVN0aWNreSgpKTtcbiAgICB9XG4gIH1cblxuICAvKlxuICAgKiBBbnl0aW1lIG5ldyBwcm9wcyBhcmUgcmVjZWl2ZWQsIGZvcmNlIHJlLWV2YWx1YXRpb25cbiAgICovXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKSB7XG4gICAgd2F0Y2hlci5lbWl0KCk7XG4gIH1cblxuICBjb21wb25lbnRXaWxsVXBkYXRlKHByb3BzLCBzdGF0ZSwgY29udGV4dCkge1xuICAgIHRoaXMuY29udGFpbmVyID0gY29udGV4dC5jb250YWluZXI7XG4gICAgdGhpcy5jb250YWluZXJOb2RlID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcy5jb250YWluZXIpO1xuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy5ub2RlID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcyk7XG4gICAgd2F0Y2hlci5vbih0aGlzLnRyYW5zaXRpb24uYmluZCh0aGlzKSk7XG4gICAgd2F0Y2hlci5lbWl0KCk7XG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB3YXRjaGVyLm9mZih0aGlzLnRyYW5zaXRpb24uYmluZCh0aGlzKSk7XG4gIH1cblxuICAvKlxuICAgKiBJZiBzdGlja3ksIG1lcmdlIHRoaXMucHJvcHMuc3RpY2t5U3R5bGUgd2l0aCB0aGlzLnByb3BzLnN0eWxlLlxuICAgKiBJZiBub3QsIGp1c3QgcmV0dXJuIHRoaXMucHJvcHMuc3R5bGUuXG4gICAqL1xuICBuZXh0U3R5bGUoc2hvdWxkQmVTdGlja3kpIHtcbiAgICBpZiAoc2hvdWxkQmVTdGlja3kpIHtcbiAgICAgIC8vIGluaGVyaXQgdGhlIGJvdW5kYXJpZXMgb2YgdGhlIGNvbnRhaW5lclxuICAgICAgdmFyIHJlY3QgPSAodGhpcy5jb250YWluZXJOb2RlIHx8IGRvY3VtZW50LmJvZHkpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIHN0eWxlID0gY29weSh7fSwgdGhpcy5wcm9wcy5zdHlsZSk7XG4gICAgICBzdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgICBzdHlsZS5sZWZ0ID0gcmVjdC5sZWZ0O1xuICAgICAgc3R5bGUud2lkdGggPSByZWN0LndpZHRoO1xuICAgICAgc3R5bGUudG9wID0gdGhpcy5vdGhlclN0aWNreU9mZnNldCgpO1xuXG4gICAgICAvLyBGaW5hbGx5LCBvdmVycmlkZSB0aGUgYmVzdC1maXQgc3R5bGUgd2l0aCBhbnkgdXNlciBwcm9wc1xuICAgICAgcmV0dXJuIGNvcHkoc3R5bGUsIHRoaXMucHJvcHMuc3RpY2t5U3R5bGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wcy5zdHlsZTtcbiAgICB9XG4gIH1cblxuICAvKlxuICAgKiBJZiBzdGlja3ksIG1lcmdlIHRoaXMucHJvcHMuc3RpY2t5Q2xhc3Mgd2l0aCB0aGlzLnByb3BzLmNsYXNzTmFtZS5cbiAgICogSWYgbm90LCBqdXN0IHJldHVybiB0aGlzLnByb3BzLmNsYXNzTmFtZS5cbiAgICovXG4gIG5leHRDbGFzc05hbWUoc2hvdWxkQmVTdGlja3kpIHtcbiAgICB2YXIgY2xhc3NOYW1lID0gdGhpcy5wcm9wcy5jbGFzc05hbWU7XG4gICAgaWYgKHNob3VsZEJlU3RpY2t5KSB7XG4gICAgICBjbGFzc05hbWUgKz0gJyAnICsgdGhpcy5wcm9wcy5zdGlja3lDbGFzcztcbiAgICB9XG4gICAgcmV0dXJuIGNsYXNzTmFtZTtcbiAgfVxuXG4gIC8qXG4gICAqIFRyYW5zaXRpb24gdG8gdGhlIG5leHQgc3RhdGUuXG4gICAqXG4gICAqIFVwZGF0ZXMgdGhlIGlzU3RpY2t5LCBzdHlsZSwgYW5kIGNsYXNzTmFtZSBzdGF0ZVxuICAgKiB2YXJpYWJsZXMuXG4gICAqXG4gICAqIElmIHN0aWNreSBzdGF0ZSBpcyBkaWZmZXJlbnQgdGhhbiB0aGUgcHJldmlvdXMsXG4gICAqIGZpcmUgdGhlIG9uU3RpY2t5U3RhdGVDaGFuZ2UgY2FsbGJhY2suXG4gICAqL1xuICBuZXh0U3RhdGUoc2hvdWxkQmVTdGlja3kpIHtcbiAgICB2YXIgaGFzQ2hhbmdlZCA9IHRoaXMuc3RhdGUuaXNTdGlja3kgIT09IHNob3VsZEJlU3RpY2t5O1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgaXNTdGlja3k6IHNob3VsZEJlU3RpY2t5LFxuICAgICAgc3R5bGU6IHRoaXMubmV4dFN0eWxlKHNob3VsZEJlU3RpY2t5KSxcbiAgICAgIGNsYXNzTmFtZTogdGhpcy5uZXh0Q2xhc3NOYW1lKHNob3VsZEJlU3RpY2t5KVxuICAgIH0pO1xuICAgIGlmIChoYXNDaGFuZ2VkKSB7XG4gICAgICB0aGlzLnByZXZlbnRCb3VuY2Uoc2hvdWxkQmVTdGlja3kpO1xuICAgICAgdGhpcy5wcm9wcy5vblN0aWNreVN0YXRlQ2hhbmdlKHNob3VsZEJlU3RpY2t5KTtcbiAgICB9XG4gIH1cblxuICBwcmV2ZW50Qm91bmNlKHNob3VsZEJlU3RpY2t5KSB7XG4gICAgbGV0IGJvdW5jZUNvcnJlY3Rpb247XG4gICAgaWYgKHNob3VsZEJlU3RpY2t5KSB7XG4gICAgICBib3VuY2VDb3JyZWN0aW9uID0gdGhpcy5ib3VuY2VDb3JyZWN0aW9uID0gTWF0aC5jZWlsKHRoaXMubm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBib3VuY2VDb3JyZWN0aW9uPSAtdGhpcy5ib3VuY2VDb3JyZWN0aW9uIHx8IDA7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbnRhaW5lcikgdGhpcy5jb250YWluZXIuc2V0VG9wQ29ycmVjdGlvbihib3VuY2VDb3JyZWN0aW9uKVxuICB9XG5cbiAgLypcbiAgICogVGhlIHNwZWNpYWwgc2F1Y2UuXG4gICAqL1xuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgc3R5bGU9e3RoaXMuc3RhdGUuc3R5bGV9IGNsYXNzTmFtZT17dGhpcy5zdGF0ZS5jbGFzc05hbWV9PlxuICAgICAgICB7dGhpcy5wcm9wcy5jaGlsZHJlbn1cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cblxuU3RpY2t5LmNvbnRleHRUeXBlcyA9IHtcbiAgY29udGFpbmVyOiBSZWFjdC5Qcm9wVHlwZXMuYW55XG59XG5cblxuLypcbiAqIERlZmF1bHQgcHJvcGVydGllcy4uLlxuICovXG5TdGlja3kuZGVmYXVsdFByb3BzID0ge1xuICBjbGFzc05hbWU6ICcnLFxuICBzdHlsZToge30sXG4gIHN0aWNreUNsYXNzOiAnc3RpY2t5JyxcbiAgc3RpY2t5U3R5bGU6IHt9LFxuICB0b3BPZmZzZXQ6IDAsXG4gIG9uU3RpY2t5U3RhdGVDaGFuZ2U6IGZ1bmN0aW9uICgpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFN0aWNreTtcbiIsImltcG9ydCB7IENoaWxkcmVuIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFN0aWNreSBmcm9tICcuL3N0aWNreSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb3B5KGRlc3QsIHNvdXJjZSkge1xuICBmb3IgKHZhciBydWxlIGluIHNvdXJjZSkge1xuICAgIGRlc3RbcnVsZV0gPSBzb3VyY2VbcnVsZV07XG4gIH07XG4gIHJldHVybiBkZXN0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmluZFN0aWNraWVzKGNoaWxkcmVuKSB7XG4gIGxldCBmb3VuZCA9IFtdO1xuICBjaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgIGlmIChjaGlsZC50eXBlID09PSBTdGlja3kpIGZvdW5kLnB1c2goY2hpbGQpO1xuICB9KTtcbiAgcmV0dXJuIGZvdW5kO1xufVxuIiwiaW1wb3J0IHJhZiBmcm9tICdyYWYnO1xuaW1wb3J0IFNpZ25hbCBmcm9tICdzaW1wbGUtc2lnbmFsJztcblxuY29uc3Qgc3RhdGUgPSB7XG4gIGhhc1VuaGFuZGxlZEV2ZW50OiBmYWxzZSxcbiAgaGFzVG91Y2hFdmVudDogZmFsc2Vcbn07XG5cbmNvbnN0IHNpZ25hbCA9IG5ldyBTaWduYWwoKTtcblxuLyoqXG4gICogV2lyZSB1cCBldmVudCBsaXN0ZW5lcnNcbiAgKi9cblsnc2Nyb2xsJywgJ3Jlc2l6ZScsICd0b3VjaG1vdmUnLCAndG91Y2hlbmQnXVxuICAuZm9yRWFjaChmdW5jdGlvbihldnQpIHtcbiAgICBpZiAod2luZG93LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlRXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cuYXR0YWNoRXZlbnQoJ29uJyArIGV2dCwgaGFuZGxlRXZlbnQpO1xuICAgIH1cbiAgfSk7XG5cblxuLy8gU3RhcnQgdGhlIGxvb3BcbnJhZihmdW5jdGlvbiB0aWNrKCkge1xuICBpZiAoc3RhdGUuaGFzVW5oYW5kbGVkRXZlbnQgfHwgc3RhdGUuaGFzVG91Y2hFdmVudCkge1xuICAgIHNpZ25hbC5lbWl0KCk7XG4gICAgc3RhdGUuaGFzVW5oYW5kbGVkRXZlbnQgPSBmYWxzZTtcbiAgfVxuICByYWYodGljayk7XG59KTtcblxuZnVuY3Rpb24gaGFuZGxlRXZlbnQoZXZlbnQpIHtcbiAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgY2FzZSAndG91Y2htb3ZlJzpcbiAgICAgIHN0YXRlLmhhc1RvdWNoRXZlbnQgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndG91Y2hlbmQnOlxuICAgICAgc3RhdGUuaGFzVG91Y2hFdmVudCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLmhhc1VuaGFuZGxlZEV2ZW50ID0gdHJ1ZTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBzaWduYWw7XG4iLCJpbXBvcnQgU3RpY2t5IGZyb20gJy4vc3RpY2t5JztcbmltcG9ydCBDb250YWluZXIgZnJvbSAnLi9jb250YWluZXInO1xuXG5TdGlja3kuQ29udGFpbmVyID0gQ29udGFpbmVyO1xuXG5leHBvcnQgZGVmYXVsdCBTdGlja3k7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNy4xXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBnZXROYW5vU2Vjb25kcywgaHJ0aW1lLCBsb2FkVGltZTtcblxuICBpZiAoKHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwZXJmb3JtYW5jZSAhPT0gbnVsbCkgJiYgcGVyZm9ybWFuY2Uubm93KSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKCh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzICE9PSBudWxsKSAmJiBwcm9jZXNzLmhydGltZSkge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gKGdldE5hbm9TZWNvbmRzKCkgLSBsb2FkVGltZSkgLyAxZTY7XG4gICAgfTtcbiAgICBocnRpbWUgPSBwcm9jZXNzLmhydGltZTtcbiAgICBnZXROYW5vU2Vjb25kcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGhyO1xuICAgICAgaHIgPSBocnRpbWUoKTtcbiAgICAgIHJldHVybiBoclswXSAqIDFlOSArIGhyWzFdO1xuICAgIH07XG4gICAgbG9hZFRpbWUgPSBnZXROYW5vU2Vjb25kcygpO1xuICB9IGVsc2UgaWYgKERhdGUubm93KSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gbG9hZFRpbWU7XG4gICAgfTtcbiAgICBsb2FkVGltZSA9IERhdGUubm93KCk7XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIGxvYWRUaW1lO1xuICAgIH07XG4gICAgbG9hZFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgfVxuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZHJhaW5RdWV1ZSwgMCk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCJ2YXIgbm93ID0gcmVxdWlyZSgncGVyZm9ybWFuY2Utbm93JylcbiAgLCByb290ID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB3aW5kb3dcbiAgLCB2ZW5kb3JzID0gWydtb3onLCAnd2Via2l0J11cbiAgLCBzdWZmaXggPSAnQW5pbWF0aW9uRnJhbWUnXG4gICwgcmFmID0gcm9vdFsncmVxdWVzdCcgKyBzdWZmaXhdXG4gICwgY2FmID0gcm9vdFsnY2FuY2VsJyArIHN1ZmZpeF0gfHwgcm9vdFsnY2FuY2VsUmVxdWVzdCcgKyBzdWZmaXhdXG5cbmZvcih2YXIgaSA9IDA7ICFyYWYgJiYgaSA8IHZlbmRvcnMubGVuZ3RoOyBpKyspIHtcbiAgcmFmID0gcm9vdFt2ZW5kb3JzW2ldICsgJ1JlcXVlc3QnICsgc3VmZml4XVxuICBjYWYgPSByb290W3ZlbmRvcnNbaV0gKyAnQ2FuY2VsJyArIHN1ZmZpeF1cbiAgICAgIHx8IHJvb3RbdmVuZG9yc1tpXSArICdDYW5jZWxSZXF1ZXN0JyArIHN1ZmZpeF1cbn1cblxuLy8gU29tZSB2ZXJzaW9ucyBvZiBGRiBoYXZlIHJBRiBidXQgbm90IGNBRlxuaWYoIXJhZiB8fCAhY2FmKSB7XG4gIHZhciBsYXN0ID0gMFxuICAgICwgaWQgPSAwXG4gICAgLCBxdWV1ZSA9IFtdXG4gICAgLCBmcmFtZUR1cmF0aW9uID0gMTAwMCAvIDYwXG5cbiAgcmFmID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICBpZihxdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHZhciBfbm93ID0gbm93KClcbiAgICAgICAgLCBuZXh0ID0gTWF0aC5tYXgoMCwgZnJhbWVEdXJhdGlvbiAtIChfbm93IC0gbGFzdCkpXG4gICAgICBsYXN0ID0gbmV4dCArIF9ub3dcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjcCA9IHF1ZXVlLnNsaWNlKDApXG4gICAgICAgIC8vIENsZWFyIHF1ZXVlIGhlcmUgdG8gcHJldmVudFxuICAgICAgICAvLyBjYWxsYmFja3MgZnJvbSBhcHBlbmRpbmcgbGlzdGVuZXJzXG4gICAgICAgIC8vIHRvIHRoZSBjdXJyZW50IGZyYW1lJ3MgcXVldWVcbiAgICAgICAgcXVldWUubGVuZ3RoID0gMFxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgY3AubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZighY3BbaV0uY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICB0cnl7XG4gICAgICAgICAgICAgIGNwW2ldLmNhbGxiYWNrKGxhc3QpXG4gICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgdGhyb3cgZSB9LCAwKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgTWF0aC5yb3VuZChuZXh0KSlcbiAgICB9XG4gICAgcXVldWUucHVzaCh7XG4gICAgICBoYW5kbGU6ICsraWQsXG4gICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICBjYW5jZWxsZWQ6IGZhbHNlXG4gICAgfSlcbiAgICByZXR1cm4gaWRcbiAgfVxuXG4gIGNhZiA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYocXVldWVbaV0uaGFuZGxlID09PSBoYW5kbGUpIHtcbiAgICAgICAgcXVldWVbaV0uY2FuY2VsbGVkID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuKSB7XG4gIC8vIFdyYXAgaW4gYSBuZXcgZnVuY3Rpb24gdG8gcHJldmVudFxuICAvLyBgY2FuY2VsYCBwb3RlbnRpYWxseSBiZWluZyBhc3NpZ25lZFxuICAvLyB0byB0aGUgbmF0aXZlIHJBRiBmdW5jdGlvblxuICByZXR1cm4gcmFmLmNhbGwocm9vdCwgZm4pXG59XG5tb2R1bGUuZXhwb3J0cy5jYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgY2FmLmFwcGx5KHJvb3QsIGFyZ3VtZW50cylcbn1cbm1vZHVsZS5leHBvcnRzLnBvbHlmaWxsID0gZnVuY3Rpb24oKSB7XG4gIHJvb3QucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gcmFmXG4gIHJvb3QuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBjYWZcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBTaWduYWw7XG5cbmZ1bmN0aW9uIFNpZ25hbCgpIHtcbiAgdmFyIHN1YnNjcmliZXJzID0gW107XG4gIHJldHVybiB7XG4gICAgb246IGZ1bmN0aW9uIG9uKGZuKSB7XG4gICAgICBzdWJzY3JpYmVycy5wdXNoKGZuKTtcbiAgICB9LFxuICAgIG9mZjogZnVuY3Rpb24gb2ZmKGZuKSB7XG4gICAgICB2YXIgaW5kZXggPSBzdWJzY3JpYmVycy5pbmRleE9mKGZuKTtcbiAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgIHN1YnNjcmliZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBlbWl0OiBmdW5jdGlvbiBlbWl0KHZhbCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHN1YnNjcmliZXJzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHN1YnNjcmliZXJzW2ldKHZhbCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdOyJdfQ==
