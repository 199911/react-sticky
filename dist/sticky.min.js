(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Sticky = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = (typeof window !== "undefined" ? window['React'] : typeof global !== "undefined" ? global['React'] : null);

var _react2 = _interopRequireDefault(_react);

var _sticky = require('./sticky');

var _sticky2 = _interopRequireDefault(_sticky);

var _utils = require('./utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Container = function (_React$Component) {
  _inherits(Container, _React$Component);

  function Container(props) {
    _classCallCheck(this, Container);

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Container).call(this, props));

    _this.state = {
      paddingTopCorrection: 0
    };
    return _this;
  }

  _createClass(Container, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.setState({ node: ReactDOM.findDOMNode(this) });
    }
  }, {
    key: 'getChildContext',
    value: function getChildContext() {
      return { container: this };
    }
  }, {
    key: 'setPaddingTopCorrection',
    value: function setPaddingTopCorrection(paddingTopCorrection) {
      this.setState({ paddingTopCorrection: paddingTopCorrection });
    }
  }, {
    key: 'render',
    value: function render() {
      var style = (0, _utils.copy)({}, this.props.style || {});

      if (this.state.node) {
        var paddingTop = style.paddingTop || parseInt(this.state.node.style.paddingTop) || 0;
        style.paddingTop = paddingTop + this.state.paddingTopCorrection;
      }

      return _react2.default.createElement(
        'div',
        _extends({}, this.props, { style: style }),
        this.props.children
      );
    }
  }]);

  return Container;
}(_react2.default.Component);

Container.childContextTypes = {
  container: _react2.default.PropTypes.any
};

exports.default = Container;
module.exports = exports['default'];

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./sticky":2,"./utils":3}],2:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = (typeof window !== "undefined" ? window['React'] : typeof global !== "undefined" ? global['React'] : null);

var _react2 = _interopRequireDefault(_react);

var _reactDom = (typeof window !== "undefined" ? window['ReactDOM'] : typeof global !== "undefined" ? global['ReactDOM'] : null);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _watcher = require('./watcher');

var _watcher2 = _interopRequireDefault(_watcher);

var _utils = require('./utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Sticky = function (_React$Component) {
  _inherits(Sticky, _React$Component);

  _createClass(Sticky, null, [{
    key: 'instancesAbove',


    /*
     * Return every Sticky instance that is
     * positioned above the supplied instance.
     */
    value: function instancesAbove(instance) {
      // var instances = [];
      // var allAbove = Sticky.__instances.slice(0, Sticky.__instances.indexOf(instance));
      // for (var i = 0; i < allAbove.length; i++) {
      //   var above = allAbove[i];
      //   if (above.container.contains(instance.container)) instances.push(above);
      // }
      return [];
    }
  }]);

  function Sticky(props) {
    _classCallCheck(this, Sticky);

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Sticky).call(this, props));

    _this.state = {};
    return _this;
  }

  /*
   * Return the distance of the scrollbar from the
   * top of the window plus the total height of all
   * stuck Sticky instances above this one.
   */


  _createClass(Sticky, [{
    key: 'pageOffset',
    value: function pageOffset() {
      return (window.pageYOffset || document.documentElement.scrollTop) + this.otherStickyOffset();
    }
  }, {
    key: 'otherStickyOffset',
    value: function otherStickyOffset() {
      var otherStickies = Sticky.instancesAbove(this);

      var offset = 0;
      for (var i = 0; i < otherStickies.length; i++) {
        var otherSticky = otherStickies[i];
        if (otherSticky.state.isSticky) {
          offset += otherSticky.domNode.getBoundingClientRect().height;
        }
      }
      return offset;
    }

    /*
     * Returns the y-coordinate of the top of this element.
     */

  }, {
    key: 'calculateOrigin',
    value: function calculateOrigin(node) {
      node = node || this.node;

      if (this.lastWidth !== window.innerWidth || this.lastHeight !== window.innerHeight) {
        this.lastWidth = window.innerWidth;
        this.lastHeight = window.innerHeight;
        var previousPosition = node.style.position;
        node.style.position = '';
        node.style.position;
        this.origin = node.getBoundingClientRect().top + this.pageOffset();
        node.style.position = previousPosition;
        return this.origin;
      } else {
        return this.origin;
      }
    }

    /*
     * Returns true/false depending on if this should be sticky.
     */

  }, {
    key: 'shouldBeSticky',
    value: function shouldBeSticky() {
      var offset = this.pageOffset();
      var origin = this.calculateOrigin();

      var stickyTopConditionsMet = offset >= origin + this.props.topOffset;
      var stickyBottomConditionsMet = offset < this.containerNode.getBoundingClientRect().height + origin - this.node.getBoundingClientRect().height;
      return stickyTopConditionsMet && stickyBottomConditionsMet;
    }
  }, {
    key: 'transition',
    value: function transition() {
      if (this.containerNode) {
        this.nextState(this.shouldBeSticky());
      }
    }

    /*
     * Anytime new props are received, force re-evaluation
     */

  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps() {
      _watcher2.default.emit();
    }
  }, {
    key: 'componentWillUpdate',
    value: function componentWillUpdate(props, state, context) {
      this.container = context.container;
      this.containerNode = _reactDom2.default.findDOMNode(this.container);
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.node = _reactDom2.default.findDOMNode(this);
      _watcher2.default.on(this.transition.bind(this));
      _watcher2.default.emit();
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      _watcher2.default.off(this.transition.bind(this));
    }

    /*
     * If sticky, merge this.props.stickyStyle with this.props.style.
     * If not, just return this.props.style.
     */

  }, {
    key: 'nextStyle',
    value: function nextStyle(shouldBeSticky) {
      if (shouldBeSticky) {
        // inherit the boundaries of the container
        var rect = (this.containerNode || document.body).getBoundingClientRect();
        var style = (0, _utils.copy)({}, this.props.style);
        style.position = 'fixed';
        style.left = rect.left;
        style.width = rect.width;
        style.top = this.otherStickyOffset();

        // Finally, override the best-fit style with any user props
        return (0, _utils.copy)(style, this.props.stickyStyle);
      } else {
        return this.props.style;
      }
    }

    /*
     * If sticky, merge this.props.stickyClass with this.props.className.
     * If not, just return this.props.className.
     */

  }, {
    key: 'nextClassName',
    value: function nextClassName(shouldBeSticky) {
      var className = this.props.className;
      if (shouldBeSticky) {
        className += ' ' + this.props.stickyClass;
      }
      return className;
    }

    /*
     * Transition to the next state.
     *
     * Updates the isSticky, style, and className state
     * variables.
     *
     * If sticky state is different than the previous,
     * fire the onStickyStateChange callback.
     */

  }, {
    key: 'nextState',
    value: function nextState(shouldBeSticky) {
      var hasChanged = this.state.isSticky !== shouldBeSticky;
      this.setState({
        isSticky: shouldBeSticky,
        style: this.nextStyle(shouldBeSticky),
        className: this.nextClassName(shouldBeSticky)
      });
      if (hasChanged) {
        this.correctBounce(shouldBeSticky);
        this.props.onStickyStateChange(shouldBeSticky);
      }
    }
  }, {
    key: 'correctBounce',
    value: function correctBounce(shouldBeSticky) {
      var bounceCorrection = undefined;
      if (shouldBeSticky) {
        bounceCorrection = this.bounceCorrection = Math.ceil(this.node.getBoundingClientRect().height);
      } else {
        bounceCorrection = -this.bounceCorrection || 0;
      }
      if (this.container) this.container.setPaddingTopCorrection(bounceCorrection);
    }

    /*
     * The special sauce.
     */

  }, {
    key: 'render',
    value: function render() {
      return _react2.default.createElement(
        'div',
        { style: this.state.style, className: this.state.className },
        this.props.children
      );
    }
  }]);

  return Sticky;
}(_react2.default.Component);

Sticky.contextTypes = {
  container: _react2.default.PropTypes.any
};

/*
 * Default properties...
 */
Sticky.defaultProps = {
  className: '',
  style: {},
  stickyClass: 'sticky',
  stickyStyle: {},
  topOffset: 0,
  onStickyStateChange: function onStickyStateChange() {}
};

exports.default = Sticky;
module.exports = exports['default'];

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./utils":3,"./watcher":4}],3:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.copy = copy;
exports.findStickies = findStickies;

var _react = (typeof window !== "undefined" ? window['React'] : typeof global !== "undefined" ? global['React'] : null);

var _sticky = require('./sticky');

var _sticky2 = _interopRequireDefault(_sticky);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function copy(dest, source) {
  for (var rule in source) {
    dest[rule] = source[rule];
  };
  return dest;
}

function findStickies(children) {
  var found = [];
  children.forEach(function (child) {
    if (child.type === _sticky2.default) found.push(child);
  });
  return found;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./sticky":2}],4:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _raf = require('raf');

var _raf2 = _interopRequireDefault(_raf);

var _simpleSignal = require('simple-signal');

var _simpleSignal2 = _interopRequireDefault(_simpleSignal);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var state = {
  hasUnhandledEvent: false,
  hasTouchEvent: false
};

var signal = new _simpleSignal2.default();

/**
  * Wire up event listeners
  */
['scroll', 'resize', 'touchmove', 'touchend'].forEach(function (evt) {
  if (window.addEventListener) {
    window.addEventListener(evt, handleEvent);
  } else {
    window.attachEvent('on' + evt, handleEvent);
  }
});

// Start the loop
(0, _raf2.default)(function tick() {
  if (state.hasUnhandledEvent || state.hasTouchEvent) {
    signal.emit();
    state.hasUnhandledEvent = false;
  }
  (0, _raf2.default)(tick);
});

function handleEvent(event) {
  switch (event.type) {
    case 'touchmove':
      state.hasTouchEvent = true;
      break;
    case 'touchend':
      state.hasTouchEvent = false;
      break;
    default:
      state.hasUnhandledEvent = true;
  }
}

exports.default = signal;
module.exports = exports['default'];

},{"raf":8,"simple-signal":9}],5:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _sticky = require('./sticky');

var _sticky2 = _interopRequireDefault(_sticky);

var _container = require('./container');

var _container2 = _interopRequireDefault(_container);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_sticky2.default.Container = _container2.default;

exports.default = _sticky2.default;
module.exports = exports['default'];

},{"./container":1,"./sticky":2}],6:[function(require,module,exports){
(function (process){
// Generated by CoffeeScript 1.7.1
(function() {
  var getNanoSeconds, hrtime, loadTime;

  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
    module.exports = function() {
      return performance.now();
    };
  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
    module.exports = function() {
      return (getNanoSeconds() - loadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    loadTime = getNanoSeconds();
  } else if (Date.now) {
    module.exports = function() {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    module.exports = function() {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }

}).call(this);

}).call(this,require('_process'))

},{"_process":7}],7:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],8:[function(require,module,exports){
(function (global){
var now = require('performance-now')
  , root = typeof window === 'undefined' ? global : window
  , vendors = ['moz', 'webkit']
  , suffix = 'AnimationFrame'
  , raf = root['request' + suffix]
  , caf = root['cancel' + suffix] || root['cancelRequest' + suffix]

for(var i = 0; !raf && i < vendors.length; i++) {
  raf = root[vendors[i] + 'Request' + suffix]
  caf = root[vendors[i] + 'Cancel' + suffix]
      || root[vendors[i] + 'CancelRequest' + suffix]
}

// Some versions of FF have rAF but not cAF
if(!raf || !caf) {
  var last = 0
    , id = 0
    , queue = []
    , frameDuration = 1000 / 60

  raf = function(callback) {
    if(queue.length === 0) {
      var _now = now()
        , next = Math.max(0, frameDuration - (_now - last))
      last = next + _now
      setTimeout(function() {
        var cp = queue.slice(0)
        // Clear queue here to prevent
        // callbacks from appending listeners
        // to the current frame's queue
        queue.length = 0
        for(var i = 0; i < cp.length; i++) {
          if(!cp[i].cancelled) {
            try{
              cp[i].callback(last)
            } catch(e) {
              setTimeout(function() { throw e }, 0)
            }
          }
        }
      }, Math.round(next))
    }
    queue.push({
      handle: ++id,
      callback: callback,
      cancelled: false
    })
    return id
  }

  caf = function(handle) {
    for(var i = 0; i < queue.length; i++) {
      if(queue[i].handle === handle) {
        queue[i].cancelled = true
      }
    }
  }
}

module.exports = function(fn) {
  // Wrap in a new function to prevent
  // `cancel` potentially being assigned
  // to the native rAF function
  return raf.call(root, fn)
}
module.exports.cancel = function() {
  caf.apply(root, arguments)
}
module.exports.polyfill = function() {
  root.requestAnimationFrame = raf
  root.cancelAnimationFrame = caf
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"performance-now":6}],9:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports["default"] = Signal;

function Signal() {
  var subscribers = [];
  return {
    on: function on(fn) {
      subscribers.push(fn);
    },
    off: function off(fn) {
      var index = subscribers.indexOf(fn);
      if (index > -1) {
        subscribers.splice(index, 1);
      }
    },
    emit: function emit(val) {
      for (var i = 0, len = subscribers.length; i < len; ++i) {
        subscribers[i](val);
      }
    }
  };
}

module.exports = exports["default"];
},{}]},{},[5])(5)
});
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJsaWIvY29udGFpbmVyLmpzIiwibGliL3N0aWNreS5qcyIsImxpYi91dGlscy5qcyIsImxpYi93YXRjaGVyLmpzIiwiaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGVyZm9ybWFuY2Utbm93L2xpYi9wZXJmb3JtYW5jZS1ub3cuanMiLCJub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JhZi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zaW1wbGUtc2lnbmFsL2xpYi9pbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lDSU07OztBQUNKLFdBREksU0FDSixDQUFZLEtBQVosRUFBbUI7MEJBRGYsV0FDZTs7dUVBRGYsc0JBRUksUUFEVzs7QUFFakIsVUFBSyxLQUFMLEdBQWE7QUFDWCw0QkFBc0IsQ0FBdEI7S0FERixDQUZpQjs7R0FBbkI7O2VBREk7O3dDQVFnQjtBQUNsQixXQUFLLFFBQUwsQ0FBYyxFQUFFLE1BQU0sU0FBUyxXQUFULENBQXFCLElBQXJCLENBQU4sRUFBaEIsRUFEa0I7Ozs7c0NBSUY7QUFDaEIsYUFBTyxFQUFFLFdBQVcsSUFBWCxFQUFULENBRGdCOzs7OzRDQUlNLHNCQUFzQjtBQUM1QyxXQUFLLFFBQUwsQ0FBYyxFQUFFLDBDQUFGLEVBQWQsRUFENEM7Ozs7NkJBSXJDO0FBQ1AsVUFBSSxRQUFRLGlCQUFLLEVBQUwsRUFBUyxLQUFLLEtBQUwsQ0FBVyxLQUFYLElBQW9CLEVBQXBCLENBQWpCLENBREc7O0FBR1AsVUFBSSxLQUFLLEtBQUwsQ0FBVyxJQUFYLEVBQWlCO0FBQ25CLFlBQUksYUFBYSxNQUFNLFVBQU4sSUFBcUIsU0FBUyxLQUFLLEtBQUwsQ0FBVyxJQUFYLENBQWdCLEtBQWhCLENBQXNCLFVBQXRCLENBQVQsSUFBOEMsQ0FBOUMsQ0FEbkI7QUFF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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgU3RpY2t5IGZyb20gJy4vc3RpY2t5JztcbmltcG9ydCB7IGNvcHkgfSBmcm9tICcuL3V0aWxzJztcblxuY2xhc3MgQ29udGFpbmVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHBhZGRpbmdUb3BDb3JyZWN0aW9uOiAwXG4gICAgfTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMuc2V0U3RhdGUoeyBub2RlOiBSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKSB9KTtcbiAgfVxuXG4gIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICByZXR1cm4geyBjb250YWluZXI6IHRoaXMgfVxuICB9XG5cbiAgc2V0UGFkZGluZ1RvcENvcnJlY3Rpb24ocGFkZGluZ1RvcENvcnJlY3Rpb24pIHtcbiAgICB0aGlzLnNldFN0YXRlKHsgcGFkZGluZ1RvcENvcnJlY3Rpb24gfSk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgbGV0IHN0eWxlID0gY29weSh7fSwgdGhpcy5wcm9wcy5zdHlsZSB8fCB7fSk7XG5cbiAgICBpZiAodGhpcy5zdGF0ZS5ub2RlKSB7XG4gICAgICBsZXQgcGFkZGluZ1RvcCA9IHN0eWxlLnBhZGRpbmdUb3AgfHwgKHBhcnNlSW50KHRoaXMuc3RhdGUubm9kZS5zdHlsZS5wYWRkaW5nVG9wKSB8fCAwKTtcbiAgICAgIHN0eWxlLnBhZGRpbmdUb3AgPSBwYWRkaW5nVG9wICsgdGhpcy5zdGF0ZS5wYWRkaW5nVG9wQ29ycmVjdGlvbjtcbiAgICB9XG5cbiAgICByZXR1cm4gPGRpdiB7Li4udGhpcy5wcm9wc30gc3R5bGU9e3N0eWxlfT5cbiAgICAgIHt0aGlzLnByb3BzLmNoaWxkcmVufVxuICAgIDwvZGl2PlxuICB9XG59XG5cbkNvbnRhaW5lci5jaGlsZENvbnRleHRUeXBlcyA9IHtcbiAgY29udGFpbmVyOiBSZWFjdC5Qcm9wVHlwZXMuYW55XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvbnRhaW5lcjtcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCB3YXRjaGVyIGZyb20gJy4vd2F0Y2hlcic7XG5pbXBvcnQgeyBjb3B5IH0gZnJvbSAnLi91dGlscyc7XG5cbmNsYXNzIFN0aWNreSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cbiAgLypcbiAgICogUmV0dXJuIGV2ZXJ5IFN0aWNreSBpbnN0YW5jZSB0aGF0IGlzXG4gICAqIHBvc2l0aW9uZWQgYWJvdmUgdGhlIHN1cHBsaWVkIGluc3RhbmNlLlxuICAgKi9cbiAgc3RhdGljIGluc3RhbmNlc0Fib3ZlKGluc3RhbmNlKSB7XG4gICAgLy8gdmFyIGluc3RhbmNlcyA9IFtdO1xuICAgIC8vIHZhciBhbGxBYm92ZSA9IFN0aWNreS5fX2luc3RhbmNlcy5zbGljZSgwLCBTdGlja3kuX19pbnN0YW5jZXMuaW5kZXhPZihpbnN0YW5jZSkpO1xuICAgIC8vIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsQWJvdmUubGVuZ3RoOyBpKyspIHtcbiAgICAvLyAgIHZhciBhYm92ZSA9IGFsbEFib3ZlW2ldO1xuICAgIC8vICAgaWYgKGFib3ZlLmNvbnRhaW5lci5jb250YWlucyhpbnN0YW5jZS5jb250YWluZXIpKSBpbnN0YW5jZXMucHVzaChhYm92ZSk7XG4gICAgLy8gfVxuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuc3RhdGUgPSB7IH07XG4gIH1cblxuICAvKlxuICAgKiBSZXR1cm4gdGhlIGRpc3RhbmNlIG9mIHRoZSBzY3JvbGxiYXIgZnJvbSB0aGVcbiAgICogdG9wIG9mIHRoZSB3aW5kb3cgcGx1cyB0aGUgdG90YWwgaGVpZ2h0IG9mIGFsbFxuICAgKiBzdHVjayBTdGlja3kgaW5zdGFuY2VzIGFib3ZlIHRoaXMgb25lLlxuICAgKi9cbiAgcGFnZU9mZnNldCgpIHtcbiAgICByZXR1cm4gKHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wKSArIHRoaXMub3RoZXJTdGlja3lPZmZzZXQoKTtcbiAgfVxuXG4gIG90aGVyU3RpY2t5T2Zmc2V0KCkge1xuICAgIHZhciBvdGhlclN0aWNraWVzID0gU3RpY2t5Lmluc3RhbmNlc0Fib3ZlKHRoaXMpO1xuXG4gICAgdmFyIG9mZnNldCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdGhlclN0aWNraWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgb3RoZXJTdGlja3kgPSBvdGhlclN0aWNraWVzW2ldO1xuICAgICAgaWYgKG90aGVyU3RpY2t5LnN0YXRlLmlzU3RpY2t5KSB7XG4gICAgICAgIG9mZnNldCArPSBvdGhlclN0aWNreS5kb21Ob2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9mZnNldDtcbiAgfVxuXG4gIC8qXG4gICAqIFJldHVybnMgdGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgdG9wIG9mIHRoaXMgZWxlbWVudC5cbiAgICovXG4gIGNhbGN1bGF0ZU9yaWdpbihub2RlKSB7XG4gICAgbm9kZSA9IG5vZGUgfHwgdGhpcy5ub2RlO1xuXG4gICAgaWYgKHRoaXMubGFzdFdpZHRoICE9PSB3aW5kb3cuaW5uZXJXaWR0aCB8fCB0aGlzLmxhc3RIZWlnaHQgIT09IHdpbmRvdy5pbm5lckhlaWdodCkge1xuICAgICAgdGhpcy5sYXN0V2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgIHRoaXMubGFzdEhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICAgIGxldCBwcmV2aW91c1Bvc2l0aW9uID0gbm9kZS5zdHlsZS5wb3NpdGlvbjtcbiAgICAgIG5vZGUuc3R5bGUucG9zaXRpb24gPSAnJztcbiAgICAgIG5vZGUuc3R5bGUucG9zaXRpb247XG4gICAgICB0aGlzLm9yaWdpbiA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wICsgdGhpcy5wYWdlT2Zmc2V0KCk7XG4gICAgICBub2RlLnN0eWxlLnBvc2l0aW9uID0gcHJldmlvdXNQb3NpdGlvbjtcbiAgICAgIHJldHVybiB0aGlzLm9yaWdpbjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMub3JpZ2luO1xuICAgIH1cbiAgfVxuXG4gIC8qXG4gICAqIFJldHVybnMgdHJ1ZS9mYWxzZSBkZXBlbmRpbmcgb24gaWYgdGhpcyBzaG91bGQgYmUgc3RpY2t5LlxuICAgKi9cbiAgc2hvdWxkQmVTdGlja3koKSB7XG4gICAgbGV0IG9mZnNldCA9IHRoaXMucGFnZU9mZnNldCgpO1xuICAgIGxldCBvcmlnaW4gPSB0aGlzLmNhbGN1bGF0ZU9yaWdpbigpO1xuXG4gICAgdmFyIHN0aWNreVRvcENvbmRpdGlvbnNNZXQgPSBvZmZzZXQgPj0gb3JpZ2luICsgdGhpcy5wcm9wcy50b3BPZmZzZXQ7XG4gICAgdmFyIHN0aWNreUJvdHRvbUNvbmRpdGlvbnNNZXQgPSBvZmZzZXQgPCB0aGlzLmNvbnRhaW5lck5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0ICsgb3JpZ2luIC0gdGhpcy5ub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgICByZXR1cm4gc3RpY2t5VG9wQ29uZGl0aW9uc01ldCAmJiBzdGlja3lCb3R0b21Db25kaXRpb25zTWV0O1xuICB9XG5cblxuICB0cmFuc2l0aW9uKCkge1xuICAgIGlmICh0aGlzLmNvbnRhaW5lck5vZGUpIHtcbiAgICAgIHRoaXMubmV4dFN0YXRlKHRoaXMuc2hvdWxkQmVTdGlja3koKSk7XG4gICAgfVxuICB9XG5cbiAgLypcbiAgICogQW55dGltZSBuZXcgcHJvcHMgYXJlIHJlY2VpdmVkLCBmb3JjZSByZS1ldmFsdWF0aW9uXG4gICAqL1xuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCkge1xuICAgIHdhdGNoZXIuZW1pdCgpO1xuICB9XG5cbiAgY29tcG9uZW50V2lsbFVwZGF0ZShwcm9wcywgc3RhdGUsIGNvbnRleHQpIHtcbiAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRleHQuY29udGFpbmVyO1xuICAgIHRoaXMuY29udGFpbmVyTm9kZSA9IFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMuY29udGFpbmVyKTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMubm9kZSA9IFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpO1xuICAgIHdhdGNoZXIub24odGhpcy50cmFuc2l0aW9uLmJpbmQodGhpcykpO1xuICAgIHdhdGNoZXIuZW1pdCgpO1xuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgd2F0Y2hlci5vZmYodGhpcy50cmFuc2l0aW9uLmJpbmQodGhpcykpO1xuICB9XG5cbiAgLypcbiAgICogSWYgc3RpY2t5LCBtZXJnZSB0aGlzLnByb3BzLnN0aWNreVN0eWxlIHdpdGggdGhpcy5wcm9wcy5zdHlsZS5cbiAgICogSWYgbm90LCBqdXN0IHJldHVybiB0aGlzLnByb3BzLnN0eWxlLlxuICAgKi9cbiAgbmV4dFN0eWxlKHNob3VsZEJlU3RpY2t5KSB7XG4gICAgaWYgKHNob3VsZEJlU3RpY2t5KSB7XG4gICAgICAvLyBpbmhlcml0IHRoZSBib3VuZGFyaWVzIG9mIHRoZSBjb250YWluZXJcbiAgICAgIHZhciByZWN0ID0gKHRoaXMuY29udGFpbmVyTm9kZSB8fCBkb2N1bWVudC5ib2R5KS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBzdHlsZSA9IGNvcHkoe30sIHRoaXMucHJvcHMuc3R5bGUpO1xuICAgICAgc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICAgICAgc3R5bGUubGVmdCA9IHJlY3QubGVmdDtcbiAgICAgIHN0eWxlLndpZHRoID0gcmVjdC53aWR0aDtcbiAgICAgIHN0eWxlLnRvcCA9IHRoaXMub3RoZXJTdGlja3lPZmZzZXQoKTtcblxuICAgICAgLy8gRmluYWxseSwgb3ZlcnJpZGUgdGhlIGJlc3QtZml0IHN0eWxlIHdpdGggYW55IHVzZXIgcHJvcHNcbiAgICAgIHJldHVybiBjb3B5KHN0eWxlLCB0aGlzLnByb3BzLnN0aWNreVN0eWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMucHJvcHMuc3R5bGU7XG4gICAgfVxuICB9XG5cbiAgLypcbiAgICogSWYgc3RpY2t5LCBtZXJnZSB0aGlzLnByb3BzLnN0aWNreUNsYXNzIHdpdGggdGhpcy5wcm9wcy5jbGFzc05hbWUuXG4gICAqIElmIG5vdCwganVzdCByZXR1cm4gdGhpcy5wcm9wcy5jbGFzc05hbWUuXG4gICAqL1xuICBuZXh0Q2xhc3NOYW1lKHNob3VsZEJlU3RpY2t5KSB7XG4gICAgdmFyIGNsYXNzTmFtZSA9IHRoaXMucHJvcHMuY2xhc3NOYW1lO1xuICAgIGlmIChzaG91bGRCZVN0aWNreSkge1xuICAgICAgY2xhc3NOYW1lICs9ICcgJyArIHRoaXMucHJvcHMuc3RpY2t5Q2xhc3M7XG4gICAgfVxuICAgIHJldHVybiBjbGFzc05hbWU7XG4gIH1cblxuICAvKlxuICAgKiBUcmFuc2l0aW9uIHRvIHRoZSBuZXh0IHN0YXRlLlxuICAgKlxuICAgKiBVcGRhdGVzIHRoZSBpc1N0aWNreSwgc3R5bGUsIGFuZCBjbGFzc05hbWUgc3RhdGVcbiAgICogdmFyaWFibGVzLlxuICAgKlxuICAgKiBJZiBzdGlja3kgc3RhdGUgaXMgZGlmZmVyZW50IHRoYW4gdGhlIHByZXZpb3VzLFxuICAgKiBmaXJlIHRoZSBvblN0aWNreVN0YXRlQ2hhbmdlIGNhbGxiYWNrLlxuICAgKi9cbiAgbmV4dFN0YXRlKHNob3VsZEJlU3RpY2t5KSB7XG4gICAgdmFyIGhhc0NoYW5nZWQgPSB0aGlzLnN0YXRlLmlzU3RpY2t5ICE9PSBzaG91bGRCZVN0aWNreTtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGlzU3RpY2t5OiBzaG91bGRCZVN0aWNreSxcbiAgICAgIHN0eWxlOiB0aGlzLm5leHRTdHlsZShzaG91bGRCZVN0aWNreSksXG4gICAgICBjbGFzc05hbWU6IHRoaXMubmV4dENsYXNzTmFtZShzaG91bGRCZVN0aWNreSlcbiAgICB9KTtcbiAgICBpZiAoaGFzQ2hhbmdlZCkge1xuICAgICAgdGhpcy5jb3JyZWN0Qm91bmNlKHNob3VsZEJlU3RpY2t5KTtcbiAgICAgIHRoaXMucHJvcHMub25TdGlja3lTdGF0ZUNoYW5nZShzaG91bGRCZVN0aWNreSk7XG4gICAgfVxuICB9XG5cbiAgY29ycmVjdEJvdW5jZShzaG91bGRCZVN0aWNreSkge1xuICAgIGxldCBib3VuY2VDb3JyZWN0aW9uO1xuICAgIGlmIChzaG91bGRCZVN0aWNreSkge1xuICAgICAgYm91bmNlQ29ycmVjdGlvbiA9IHRoaXMuYm91bmNlQ29ycmVjdGlvbiA9IE1hdGguY2VpbCh0aGlzLm5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYm91bmNlQ29ycmVjdGlvbj0gLXRoaXMuYm91bmNlQ29ycmVjdGlvbiB8fCAwO1xuICAgIH1cbiAgICBpZiAodGhpcy5jb250YWluZXIpIHRoaXMuY29udGFpbmVyLnNldFBhZGRpbmdUb3BDb3JyZWN0aW9uKGJvdW5jZUNvcnJlY3Rpb24pIFxuICB9XG5cbiAgLypcbiAgICogVGhlIHNwZWNpYWwgc2F1Y2UuXG4gICAqL1xuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgc3R5bGU9e3RoaXMuc3RhdGUuc3R5bGV9IGNsYXNzTmFtZT17dGhpcy5zdGF0ZS5jbGFzc05hbWV9PlxuICAgICAgICB7dGhpcy5wcm9wcy5jaGlsZHJlbn1cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cblxuU3RpY2t5LmNvbnRleHRUeXBlcyA9IHtcbiAgY29udGFpbmVyOiBSZWFjdC5Qcm9wVHlwZXMuYW55XG59XG5cblxuLypcbiAqIERlZmF1bHQgcHJvcGVydGllcy4uLlxuICovXG5TdGlja3kuZGVmYXVsdFByb3BzID0ge1xuICBjbGFzc05hbWU6ICcnLFxuICBzdHlsZToge30sXG4gIHN0aWNreUNsYXNzOiAnc3RpY2t5JyxcbiAgc3RpY2t5U3R5bGU6IHt9LFxuICB0b3BPZmZzZXQ6IDAsXG4gIG9uU3RpY2t5U3RhdGVDaGFuZ2U6IGZ1bmN0aW9uICgpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFN0aWNreTtcbiIsImltcG9ydCB7IENoaWxkcmVuIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFN0aWNreSBmcm9tICcuL3N0aWNreSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb3B5KGRlc3QsIHNvdXJjZSkge1xuICBmb3IgKHZhciBydWxlIGluIHNvdXJjZSkge1xuICAgIGRlc3RbcnVsZV0gPSBzb3VyY2VbcnVsZV07XG4gIH07XG4gIHJldHVybiBkZXN0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmluZFN0aWNraWVzKGNoaWxkcmVuKSB7XG4gIGxldCBmb3VuZCA9IFtdO1xuICBjaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgIGlmIChjaGlsZC50eXBlID09PSBTdGlja3kpIGZvdW5kLnB1c2goY2hpbGQpO1xuICB9KTtcbiAgcmV0dXJuIGZvdW5kO1xufVxuIiwiaW1wb3J0IHJhZiBmcm9tICdyYWYnO1xuaW1wb3J0IFNpZ25hbCBmcm9tICdzaW1wbGUtc2lnbmFsJztcblxuY29uc3Qgc3RhdGUgPSB7XG4gIGhhc1VuaGFuZGxlZEV2ZW50OiBmYWxzZSxcbiAgaGFzVG91Y2hFdmVudDogZmFsc2Vcbn07XG5cbmNvbnN0IHNpZ25hbCA9IG5ldyBTaWduYWwoKTtcblxuLyoqXG4gICogV2lyZSB1cCBldmVudCBsaXN0ZW5lcnNcbiAgKi9cblsnc2Nyb2xsJywgJ3Jlc2l6ZScsICd0b3VjaG1vdmUnLCAndG91Y2hlbmQnXVxuICAuZm9yRWFjaChmdW5jdGlvbihldnQpIHtcbiAgICBpZiAod2luZG93LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlRXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cuYXR0YWNoRXZlbnQoJ29uJyArIGV2dCwgaGFuZGxlRXZlbnQpO1xuICAgIH1cbiAgfSk7XG5cblxuLy8gU3RhcnQgdGhlIGxvb3BcbnJhZihmdW5jdGlvbiB0aWNrKCkge1xuICBpZiAoc3RhdGUuaGFzVW5oYW5kbGVkRXZlbnQgfHwgc3RhdGUuaGFzVG91Y2hFdmVudCkge1xuICAgIHNpZ25hbC5lbWl0KCk7XG4gICAgc3RhdGUuaGFzVW5oYW5kbGVkRXZlbnQgPSBmYWxzZTtcbiAgfVxuICByYWYodGljayk7XG59KTtcblxuZnVuY3Rpb24gaGFuZGxlRXZlbnQoZXZlbnQpIHtcbiAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgY2FzZSAndG91Y2htb3ZlJzpcbiAgICAgIHN0YXRlLmhhc1RvdWNoRXZlbnQgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndG91Y2hlbmQnOlxuICAgICAgc3RhdGUuaGFzVG91Y2hFdmVudCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLmhhc1VuaGFuZGxlZEV2ZW50ID0gdHJ1ZTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBzaWduYWw7XG4iLCJpbXBvcnQgU3RpY2t5IGZyb20gJy4vc3RpY2t5JztcbmltcG9ydCBDb250YWluZXIgZnJvbSAnLi9jb250YWluZXInO1xuXG5TdGlja3kuQ29udGFpbmVyID0gQ29udGFpbmVyO1xuXG5leHBvcnQgZGVmYXVsdCBTdGlja3k7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNy4xXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBnZXROYW5vU2Vjb25kcywgaHJ0aW1lLCBsb2FkVGltZTtcblxuICBpZiAoKHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwZXJmb3JtYW5jZSAhPT0gbnVsbCkgJiYgcGVyZm9ybWFuY2Uubm93KSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKCh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzICE9PSBudWxsKSAmJiBwcm9jZXNzLmhydGltZSkge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gKGdldE5hbm9TZWNvbmRzKCkgLSBsb2FkVGltZSkgLyAxZTY7XG4gICAgfTtcbiAgICBocnRpbWUgPSBwcm9jZXNzLmhydGltZTtcbiAgICBnZXROYW5vU2Vjb25kcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGhyO1xuICAgICAgaHIgPSBocnRpbWUoKTtcbiAgICAgIHJldHVybiBoclswXSAqIDFlOSArIGhyWzFdO1xuICAgIH07XG4gICAgbG9hZFRpbWUgPSBnZXROYW5vU2Vjb25kcygpO1xuICB9IGVsc2UgaWYgKERhdGUubm93KSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gbG9hZFRpbWU7XG4gICAgfTtcbiAgICBsb2FkVGltZSA9IERhdGUubm93KCk7XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIGxvYWRUaW1lO1xuICAgIH07XG4gICAgbG9hZFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgfVxuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZHJhaW5RdWV1ZSwgMCk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCJ2YXIgbm93ID0gcmVxdWlyZSgncGVyZm9ybWFuY2Utbm93JylcbiAgLCByb290ID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB3aW5kb3dcbiAgLCB2ZW5kb3JzID0gWydtb3onLCAnd2Via2l0J11cbiAgLCBzdWZmaXggPSAnQW5pbWF0aW9uRnJhbWUnXG4gICwgcmFmID0gcm9vdFsncmVxdWVzdCcgKyBzdWZmaXhdXG4gICwgY2FmID0gcm9vdFsnY2FuY2VsJyArIHN1ZmZpeF0gfHwgcm9vdFsnY2FuY2VsUmVxdWVzdCcgKyBzdWZmaXhdXG5cbmZvcih2YXIgaSA9IDA7ICFyYWYgJiYgaSA8IHZlbmRvcnMubGVuZ3RoOyBpKyspIHtcbiAgcmFmID0gcm9vdFt2ZW5kb3JzW2ldICsgJ1JlcXVlc3QnICsgc3VmZml4XVxuICBjYWYgPSByb290W3ZlbmRvcnNbaV0gKyAnQ2FuY2VsJyArIHN1ZmZpeF1cbiAgICAgIHx8IHJvb3RbdmVuZG9yc1tpXSArICdDYW5jZWxSZXF1ZXN0JyArIHN1ZmZpeF1cbn1cblxuLy8gU29tZSB2ZXJzaW9ucyBvZiBGRiBoYXZlIHJBRiBidXQgbm90IGNBRlxuaWYoIXJhZiB8fCAhY2FmKSB7XG4gIHZhciBsYXN0ID0gMFxuICAgICwgaWQgPSAwXG4gICAgLCBxdWV1ZSA9IFtdXG4gICAgLCBmcmFtZUR1cmF0aW9uID0gMTAwMCAvIDYwXG5cbiAgcmFmID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICBpZihxdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHZhciBfbm93ID0gbm93KClcbiAgICAgICAgLCBuZXh0ID0gTWF0aC5tYXgoMCwgZnJhbWVEdXJhdGlvbiAtIChfbm93IC0gbGFzdCkpXG4gICAgICBsYXN0ID0gbmV4dCArIF9ub3dcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjcCA9IHF1ZXVlLnNsaWNlKDApXG4gICAgICAgIC8vIENsZWFyIHF1ZXVlIGhlcmUgdG8gcHJldmVudFxuICAgICAgICAvLyBjYWxsYmFja3MgZnJvbSBhcHBlbmRpbmcgbGlzdGVuZXJzXG4gICAgICAgIC8vIHRvIHRoZSBjdXJyZW50IGZyYW1lJ3MgcXVldWVcbiAgICAgICAgcXVldWUubGVuZ3RoID0gMFxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgY3AubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZighY3BbaV0uY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICB0cnl7XG4gICAgICAgICAgICAgIGNwW2ldLmNhbGxiYWNrKGxhc3QpXG4gICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgdGhyb3cgZSB9LCAwKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgTWF0aC5yb3VuZChuZXh0KSlcbiAgICB9XG4gICAgcXVldWUucHVzaCh7XG4gICAgICBoYW5kbGU6ICsraWQsXG4gICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICBjYW5jZWxsZWQ6IGZhbHNlXG4gICAgfSlcbiAgICByZXR1cm4gaWRcbiAgfVxuXG4gIGNhZiA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYocXVldWVbaV0uaGFuZGxlID09PSBoYW5kbGUpIHtcbiAgICAgICAgcXVldWVbaV0uY2FuY2VsbGVkID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuKSB7XG4gIC8vIFdyYXAgaW4gYSBuZXcgZnVuY3Rpb24gdG8gcHJldmVudFxuICAvLyBgY2FuY2VsYCBwb3RlbnRpYWxseSBiZWluZyBhc3NpZ25lZFxuICAvLyB0byB0aGUgbmF0aXZlIHJBRiBmdW5jdGlvblxuICByZXR1cm4gcmFmLmNhbGwocm9vdCwgZm4pXG59XG5tb2R1bGUuZXhwb3J0cy5jYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgY2FmLmFwcGx5KHJvb3QsIGFyZ3VtZW50cylcbn1cbm1vZHVsZS5leHBvcnRzLnBvbHlmaWxsID0gZnVuY3Rpb24oKSB7XG4gIHJvb3QucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gcmFmXG4gIHJvb3QuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBjYWZcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBTaWduYWw7XG5cbmZ1bmN0aW9uIFNpZ25hbCgpIHtcbiAgdmFyIHN1YnNjcmliZXJzID0gW107XG4gIHJldHVybiB7XG4gICAgb246IGZ1bmN0aW9uIG9uKGZuKSB7XG4gICAgICBzdWJzY3JpYmVycy5wdXNoKGZuKTtcbiAgICB9LFxuICAgIG9mZjogZnVuY3Rpb24gb2ZmKGZuKSB7XG4gICAgICB2YXIgaW5kZXggPSBzdWJzY3JpYmVycy5pbmRleE9mKGZuKTtcbiAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgIHN1YnNjcmliZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBlbWl0OiBmdW5jdGlvbiBlbWl0KHZhbCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHN1YnNjcmliZXJzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHN1YnNjcmliZXJzW2ldKHZhbCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdOyJdfQ==
