(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Sticky = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var STICKY_CONTAINER_ATTR = exports.STICKY_CONTAINER_ATTR = 'data-sticky-container';

},{}],2:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _constants = require('./constants');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Container = function (_React$Component) {
  _inherits(Container, _React$Component);

  function Container(props) {
    _classCallCheck(this, Container);

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Container).call(this, props));

    _this.state = {};
    _this.state[_constants.STICKY_CONTAINER_ATTR] = '';
    return _this;
  }

  _createClass(Container, [{
    key: 'render',
    value: function render() {
      return React.createElement(
        'div',
        _extends({}, this.props, this.state),
        this.props.children
      );
    }
  }]);

  return Container;
}(React.Component);

exports.default = Container;
module.exports = exports['default'];

},{"./constants":1}],3:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = (typeof window !== "undefined" ? window['React'] : typeof global !== "undefined" ? global['React'] : null);

var _react2 = _interopRequireDefault(_react);

var _reactDom = (typeof window !== "undefined" ? window['ReactDOM'] : typeof global !== "undefined" ? global['ReactDOM'] : null);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _constants = require('./constants');

var _watcher = require('./watcher');

var _watcher2 = _interopRequireDefault(_watcher);

var _utils = require('./utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Sticky = function (_React$Component) {
  _inherits(Sticky, _React$Component);

  _createClass(Sticky, null, [{
    key: 'instancesAbove',


    /*
     * Return every Sticky instance that is
     * positioned above the supplied instance.
     */
    value: function instancesAbove(instance) {
      // var instances = [];
      // var allAbove = Sticky.__instances.slice(0, Sticky.__instances.indexOf(instance));
      // for (var i = 0; i < allAbove.length; i++) {
      //   var above = allAbove[i];
      //   if (above.container.contains(instance.container)) instances.push(above);
      // }
      return [];
    }
  }]);

  function Sticky(props) {
    _classCallCheck(this, Sticky);

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Sticky).call(this, props));

    _this.state = {};
    return _this;
  }

  /*
   * Return the distance of the scrollbar from the
   * top of the window plus the total height of all
   * stuck Sticky instances above this one.
   */


  _createClass(Sticky, [{
    key: 'pageOffset',
    value: function pageOffset() {
      return (window.pageYOffset || document.documentElement.scrollTop) + this.otherStickyOffset();
    }
  }, {
    key: 'otherStickyOffset',
    value: function otherStickyOffset() {
      var otherStickies = Sticky.instancesAbove(this);

      var offset = 0;
      for (var i = 0; i < otherStickies.length; i++) {
        var otherSticky = otherStickies[i];
        if (otherSticky.state.isSticky) {
          offset += otherSticky.domNode.getBoundingClientRect().height;
        }
      }
      return offset;
    }
  }, {
    key: 'containerOf',
    value: function containerOf(node) {
      var container = node.parentNode || document.body;
      while (container !== document.body && !container.hasAttribute(_constants.STICKY_CONTAINER_ATTR)) {
        container = container.parentNode;
      }
      return container;
    }

    /*
     * Returns the y-coordinate of the top of this element.
     */

  }, {
    key: 'top',
    value: function top() {
      return this.domNode.getBoundingClientRect().top;
    }

    /*
     * Returns true/false depending on if this should be sticky.
     */

  }, {
    key: 'shouldBeSticky',
    value: function shouldBeSticky() {
      var offset = this.pageOffset();
      var stickyTopConditionsMet = offset >= this.origin + this.props.topOffset;
      var stickyBottomConditionsMet = this.container === document.body ? true : offset < this.container.getBoundingClientRect().height + this.origin - this.domNode.getBoundingClientRect().height;

      return stickyTopConditionsMet && stickyBottomConditionsMet;
    }
  }, {
    key: 'handleUpdate',
    value: function handleUpdate() {
      console.log('updating!');
      var shouldBeSticky = this.shouldBeSticky();
      this.nextState(shouldBeSticky);
    }

    /*
     * Anytime new props are received, force re-evaluation
     */

  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps() {
      _watcher2.default.emit();
    }

    /*
     * Instance was mounted on the page.
     *
     * In order, this function should:
     *  - Register events listeners with window.
     *  - Cache the domNode using ReactDOM.findDOMNode.
     *  - Store the initial y-position (origin) of this
     *    instance.
     *  - Register this instance, subscribing to animation
     *    loop.
     */

  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.domNode = _reactDom2.default.findDOMNode(this);
      this.container = this.containerOf(this.domNode);
      this.origin = this.top() + this.pageOffset();

      _watcher2.default.on(this.handleUpdate.bind(this));
      _watcher2.default.emit();
    }

    /*
     * Instance was removed from the page.
     *
     * Undo everything during mounting.
     */

  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.domNode = null;

      _watcher2.default.off(this.handleUpdate.bind(this));
    }

    /*
     * If sticky, merge this.props.stickyStyle with this.props.style.
     * If not, just return this.props.style.
     */

  }, {
    key: 'nextStyle',
    value: function nextStyle(shouldBeSticky) {
      if (shouldBeSticky) {
        // inherit the boundaries of the container
        var rect = this.container.getBoundingClientRect();
        var style = (0, _utils.copy)({}, this.props.style);
        style.position = 'fixed';
        style.left = rect.left;
        style.width = rect.width;
        style.top = this.otherStickyOffset();
        console.log(this.domNode, this.container, this.pageOffset());

        // Finally, override the best-fit style with any user props
        return (0, _utils.copy)(style, this.props.stickyStyle);
      } else {
        return this.props.style;
      }
    }

    /*
     * If sticky, merge this.props.stickyClass with this.props.className.
     * If not, just return this.props.className.
     */

  }, {
    key: 'nextClassName',
    value: function nextClassName(shouldBeSticky) {
      var className = this.props.className;
      if (shouldBeSticky) {
        className += ' ' + this.props.stickyClass;
      }
      return className;
    }

    /*
     * Transition to the next state.
     *
     * Updates the isSticky, style, and className state
     * variables.
     *
     * If sticky state is different than the previous,
     * fire the onStickyStateChange callback.
     */

  }, {
    key: 'nextState',
    value: function nextState(shouldBeSticky) {
      var hasChanged = this.state.isSticky !== shouldBeSticky;
      this.setState({
        isSticky: shouldBeSticky,
        style: this.nextStyle(shouldBeSticky),
        className: this.nextClassName(shouldBeSticky)
      });
      if (hasChanged) {
        this.correctBounce(shouldBeSticky);
        this.props.onStickyStateChange(shouldBeSticky);
      }
    }
  }, {
    key: 'correctBounce',
    value: function correctBounce(shouldBeSticky) {
      var bounceCorrection;
      if (shouldBeSticky) {
        bounceCorrection = this.bounceCorrection = Math.ceil(this.domNode.getBoundingClientRect().height);
      } else {
        bounceCorrection = -this.bounceCorrection;
      }
      var paddingTop = (parseInt(this.container.style.paddingTop) || 0) + bounceCorrection;
      this.container.style.paddingTop = paddingTop + 'px';
    }

    /*
     * The special sauce.
     */

  }, {
    key: 'render',
    value: function render() {
      return _react2.default.createElement(
        'div',
        { style: this.state.style, className: this.state.className },
        this.props.children
      );
    }
  }]);

  return Sticky;
}(_react2.default.Component);

/*
 * Default properties...
 */


Sticky.defaultProps = {
  className: '',
  style: {},
  stickyClass: 'sticky',
  stickyStyle: {},
  topOffset: 0,
  onStickyStateChange: function onStickyStateChange() {}
};

exports.default = Sticky;
module.exports = exports['default'];

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./constants":1,"./utils":4,"./watcher":5}],4:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.copy = copy;
function copy(dest, source) {
  for (var rule in source) {
    dest[rule] = source[rule];
  };
  return dest;
}

},{}],5:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _raf = require('raf');

var _raf2 = _interopRequireDefault(_raf);

var _simpleSignal = require('simple-signal');

var _simpleSignal2 = _interopRequireDefault(_simpleSignal);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var state = {
  hasUnhandledEvent: false,
  hasTouchEvent: false
};

var signal = new _simpleSignal2.default();

/**
  * Wire up event listeners
  */
['scroll', 'resize', 'touchmove', 'touchend'].forEach(function (type) {
  if (window.addEventListener) {
    window.addEventListener(type, handleEvent);
  } else {
    window.attachEvent('on' + type, handleEvent);
  }
});

// Start the loop
(0, _raf2.default)(function tick() {
  if (state.hasUnhandledEvent || state.hasTouchEvent) {
    console.log('emitter');
    signal.emit();
    state.hasUnhandledEvent = false;
  }
  (0, _raf2.default)(tick);
});

/*
 * Lightweight event listener for window events.
 *
 * See http://www.html5rocks.com/en/tutorials/speed/animations/
 */
function handleEvent(event) {
  switch (event.type) {
    case 'touchmove':
      state.hasTouchEvent = true;
      break;
    case 'touchend':
      state.hasTouchEvent = false;
      break;
    default:
      state.hasUnhandledEvent = true;
  }
}

exports.default = signal;
module.exports = exports['default'];

},{"raf":9,"simple-signal":10}],6:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _sticky = require('./sticky');

var _sticky2 = _interopRequireDefault(_sticky);

var _container = require('./container');

var _container2 = _interopRequireDefault(_container);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_sticky2.default.Container = _container2.default;

exports.default = _sticky2.default;
module.exports = exports['default'];

},{"./container":2,"./sticky":3}],7:[function(require,module,exports){
(function (process){
// Generated by CoffeeScript 1.7.1
(function() {
  var getNanoSeconds, hrtime, loadTime;

  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
    module.exports = function() {
      return performance.now();
    };
  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
    module.exports = function() {
      return (getNanoSeconds() - loadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    loadTime = getNanoSeconds();
  } else if (Date.now) {
    module.exports = function() {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    module.exports = function() {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }

}).call(this);

}).call(this,require('_process'))

},{"_process":8}],8:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],9:[function(require,module,exports){
(function (global){
var now = require('performance-now')
  , root = typeof window === 'undefined' ? global : window
  , vendors = ['moz', 'webkit']
  , suffix = 'AnimationFrame'
  , raf = root['request' + suffix]
  , caf = root['cancel' + suffix] || root['cancelRequest' + suffix]

for(var i = 0; !raf && i < vendors.length; i++) {
  raf = root[vendors[i] + 'Request' + suffix]
  caf = root[vendors[i] + 'Cancel' + suffix]
      || root[vendors[i] + 'CancelRequest' + suffix]
}

// Some versions of FF have rAF but not cAF
if(!raf || !caf) {
  var last = 0
    , id = 0
    , queue = []
    , frameDuration = 1000 / 60

  raf = function(callback) {
    if(queue.length === 0) {
      var _now = now()
        , next = Math.max(0, frameDuration - (_now - last))
      last = next + _now
      setTimeout(function() {
        var cp = queue.slice(0)
        // Clear queue here to prevent
        // callbacks from appending listeners
        // to the current frame's queue
        queue.length = 0
        for(var i = 0; i < cp.length; i++) {
          if(!cp[i].cancelled) {
            try{
              cp[i].callback(last)
            } catch(e) {
              setTimeout(function() { throw e }, 0)
            }
          }
        }
      }, Math.round(next))
    }
    queue.push({
      handle: ++id,
      callback: callback,
      cancelled: false
    })
    return id
  }

  caf = function(handle) {
    for(var i = 0; i < queue.length; i++) {
      if(queue[i].handle === handle) {
        queue[i].cancelled = true
      }
    }
  }
}

module.exports = function(fn) {
  // Wrap in a new function to prevent
  // `cancel` potentially being assigned
  // to the native rAF function
  return raf.call(root, fn)
}
module.exports.cancel = function() {
  caf.apply(root, arguments)
}
module.exports.polyfill = function() {
  root.requestAnimationFrame = raf
  root.cancelAnimationFrame = caf
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"performance-now":7}],10:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports["default"] = Signal;

function Signal() {
  var subscribers = [];
  return {
    on: function on(fn) {
      subscribers.push(fn);
    },
    off: function off(fn) {
      var index = subscribers.indexOf(fn);
      if (index > -1) {
        subscribers.splice(index, 1);
      }
    },
    emit: function emit(val) {
      for (var i = 0, len = subscribers.length; i < len; ++i) {
        subscribers[i](val);
      }
    }
  };
}

module.exports = exports["default"];
},{}]},{},[6])(6)
});
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJsaWIvY29uc3RhbnRzLmpzIiwibGliL2NvbnRhaW5lci5qcyIsImxpYi9zdGlja3kuanMiLCJsaWIvdXRpbHMuanMiLCJsaWIvd2F0Y2hlci5qcyIsImluZGV4LmpzIiwibm9kZV9tb2R1bGVzL3BlcmZvcm1hbmNlLW5vdy9saWIvcGVyZm9ybWFuY2Utbm93LmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yYWYvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc2ltcGxlLXNpZ25hbC9saWIvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztBQ0FPLElBQU0sd0RBQXdCLHVCQUF4Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lDRVA7OztBQUVKLFdBRkksU0FFSixDQUFZLEtBQVosRUFBbUI7MEJBRmYsV0FFZTs7dUVBRmYsc0JBR0ksUUFEVzs7QUFFakIsVUFBSyxLQUFMLEdBQWEsRUFBYixDQUZpQjtBQUdqQixVQUFLLEtBQUwscUNBQW9DLEVBQXBDLENBSGlCOztHQUFuQjs7ZUFGSTs7NkJBUUs7QUFDUCxhQUFPOztxQkFBUyxLQUFLLEtBQUwsRUFBZ0IsS0FBSyxLQUFMLENBQXpCO1FBQXNDLEtBQUssS0FBTCxDQUFXLFFBQVg7T0FBN0MsQ0FETzs7OztTQVJMO0VBQWtCLE1BQU0sU0FBTjs7a0JBYVQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUNUVDs7Ozs7Ozs7Ozs7bUNBTWtCLFVBQVU7Ozs7Ozs7QUFPOUIsYUFBTyxFQUFQLENBUDhCOzs7O0FBV2hDLFdBakJJLE1BaUJKLENBQVksS0FBWixFQUFtQjswQkFqQmYsUUFpQmU7O3VFQWpCZixtQkFrQkksUUFEVzs7QUFFakIsVUFBSyxLQUFMLEdBQWEsRUFBYixDQUZpQjs7R0FBbkI7Ozs7Ozs7OztlQWpCSTs7aUNBMkJTO0FBQ1gsYUFBTyxDQUFDLE9BQU8sV0FBUCxJQUFzQixTQUFTLGVBQVQsQ0FBeUIsU0FBekIsQ0FBdkIsR0FBNkQsS0FBSyxpQkFBTCxFQUE3RCxDQURJOzs7O3dDQUlPO0FBQ2xCLFVBQUksZ0JBQWdCLE9BQU8sY0FBUCxDQUFzQixJQUF0QixDQUFoQixDQURjOztBQUdsQixVQUFJLFNBQVMsQ0FBVCxDQUhjO0FBSWxCLFdBQUssSUFBSSxJQUFJLENBQUosRUFBTyxJQUFJLGNBQWMsTUFBZCxFQUFzQixHQUExQyxFQUErQztBQUM3QyxZQUFJLGNBQWMsY0FBYyxDQUFkLENBQWQsQ0FEeUM7QUFFN0MsWUFBSSxZQUFZLEtBQVosQ0FBa0IsUUFBbEIsRUFBNEI7QUFDOUIsb0JBQVUsWUFBWSxPQUFaLENBQW9CLHFCQUFwQixHQUE0QyxNQUE1QyxDQURvQjtTQUFoQztPQUZGO0FBTUEsYUFBTyxNQUFQLENBVmtCOzs7O2dDQWFSLE1BQU07QUFDaEIsVUFBSSxZQUFZLEtBQUssVUFBTCxJQUFtQixTQUFTLElBQVQsQ0FEbkI7QUFFaEIsYUFBTyxjQUFjLFNBQVMsSUFBVCxJQUNoQixDQUFDLFVBQVUsWUFBVixrQ0FBRCxFQUFnRDtBQUNuRCxvQkFBWSxVQUFVLFVBQVYsQ0FEdUM7T0FEckQ7QUFJQSxhQUFPLFNBQVAsQ0FOZ0I7Ozs7Ozs7OzswQkFZWjtBQUNKLGFBQU8sS0FBSyxPQUFMLENBQWEscUJBQWIsR0FBcUMsR0FBckMsQ0FESDs7Ozs7Ozs7O3FDQU9XO0FBQ2YsVUFBSSxTQUFTLEtBQUssVUFBTCxFQUFULENBRFc7QUFFZixVQUFJLHlCQUF5QixVQUFVLEtBQUssTUFBTCxHQUFjLEtBQUssS0FBTCxDQUFXLFNBQVgsQ0FGdEM7QUFHZixVQUFJLDRCQUE0QixLQUFLLFNBQUwsS0FBbUIsU0FBUyxJQUFULEdBQWdCLElBQW5DLEdBQTBDLFNBQVMsS0FBSyxTQUFMLENBQWUscUJBQWYsR0FBdUMsTUFBdkMsR0FBZ0QsS0FBSyxNQUFMLEdBQWMsS0FBSyxPQUFMLENBQWEscUJBQWIsR0FBcUMsTUFBckMsQ0FIbEk7O0FBS2YsYUFBTywwQkFBMEIseUJBQTFCLENBTFE7Ozs7bUNBU0Y7QUFDYixjQUFRLEdBQVIsQ0FBWSxXQUFaLEVBRGE7QUFFYixVQUFJLGlCQUFpQixLQUFLLGNBQUwsRUFBakIsQ0FGUztBQUdiLFdBQUssU0FBTCxDQUFlLGNBQWYsRUFIYTs7Ozs7Ozs7O2dEQVNhO0FBQzFCLHdCQUFRLElBQVIsR0FEMEI7Ozs7Ozs7Ozs7Ozs7Ozs7O3dDQWVSO0FBQ2xCLFdBQUssT0FBTCxHQUFlLG1CQUFTLFdBQVQsQ0FBcUIsSUFBckIsQ0FBZixDQURrQjtBQUVsQixXQUFLLFNBQUwsR0FBaUIsS0FBSyxXQUFMLENBQWlCLEtBQUssT0FBTCxDQUFsQyxDQUZrQjtBQUdsQixXQUFLLE1BQUwsR0FBYyxLQUFLLEdBQUwsS0FBYSxLQUFLLFVBQUwsRUFBYixDQUhJOztBQUtsQix3QkFBUSxFQUFSLENBQVcsS0FBSyxZQUFMLENBQWtCLElBQWxCLENBQXVCLElBQXZCLENBQVgsRUFMa0I7QUFNbEIsd0JBQVEsSUFBUixHQU5rQjs7Ozs7Ozs7Ozs7MkNBY0c7QUFDckIsV0FBSyxPQUFMLEdBQWUsSUFBZixDQURxQjs7QUFHckIsd0JBQVEsR0FBUixDQUFZLEtBQUssWUFBTCxDQUFrQixJQUFsQixDQUF1QixJQUF2QixDQUFaLEVBSHFCOzs7Ozs7Ozs7OzhCQVViLGdCQUFnQjtBQUN4QixVQUFJLGNBQUosRUFBb0I7O0FBRWxCLFlBQUksT0FBTyxLQUFLLFNBQUwsQ0FBZSxxQkFBZixFQUFQLENBRmM7QUFHbEIsWUFBSSxRQUFRLGlCQUFLLEVBQUwsRUFBUyxLQUFLLEtBQUwsQ0FBVyxLQUFYLENBQWpCLENBSGM7QUFJbEIsY0FBTSxRQUFOLEdBQWlCLE9BQWpCLENBSmtCO0FBS2xCLGNBQU0sSUFBTixHQUFhLEtBQUssSUFBTCxDQUxLO0FBTWxCLGNBQU0sS0FBTixHQUFjLEtBQUssS0FBTCxDQU5JO0FBT2xCLGNBQU0sR0FBTixHQUFZLEtBQUssaUJBQUwsRUFBWixDQVBrQjtBQVFsQixnQkFBUSxHQUFSLENBQVksS0FBSyxPQUFMLEVBQWMsS0FBSyxTQUFMLEVBQWdCLEtBQUssVUFBTCxFQUExQzs7O0FBUmtCLGVBV1gsaUJBQUssS0FBTCxFQUFZLEtBQUssS0FBTCxDQUFXLFdBQVgsQ0FBbkIsQ0FYa0I7T0FBcEIsTUFZTztBQUNMLGVBQU8sS0FBSyxLQUFMLENBQVcsS0FBWCxDQURGO09BWlA7Ozs7Ozs7Ozs7a0NBcUJZLGdCQUFnQjtBQUM1QixVQUFJLFlBQVksS0FBSyxLQUFMLENBQVcsU0FBWCxDQURZO0FBRTVCLFVBQUksY0FBSixFQUFvQjtBQUNsQixxQkFBYSxNQUFNLEtBQUssS0FBTCxDQUFXLFdBQVgsQ0FERDtPQUFwQjtBQUdBLGFBQU8sU0FBUCxDQUw0Qjs7Ozs7Ozs7Ozs7Ozs7OzhCQWlCcEIsZ0JBQWdCO0FBQ3hCLFVBQUksYUFBYSxLQUFLLEtBQUwsQ0FBVyxRQUFYLEtBQXdCLGNBQXhCLENBRE87QUFFeEIsV0FBSyxRQUFMLENBQWM7QUFDWixrQkFBVSxjQUFWO0FBQ0EsZUFBTyxLQUFLLFNBQUwsQ0FBZSxjQUFmLENBQVA7QUFDQSxtQkFBVyxLQUFLLGFBQUwsQ0FBbUIsY0FBbkIsQ0FBWDtPQUhGLEVBRndCO0FBT3hCLFVBQUksVUFBSixFQUFnQjtBQUNkLGFBQUssYUFBTCxDQUFtQixjQUFuQixFQURjO0FBRWQsYUFBSyxLQUFMLENBQVcsbUJBQVgsQ0FBK0IsY0FBL0IsRUFGYztPQUFoQjs7OztrQ0FNWSxnQkFBZ0I7QUFDNUIsVUFBSSxnQkFBSixDQUQ0QjtBQUU1QixVQUFJLGNBQUosRUFBb0I7QUFDbEIsMkJBQW1CLEtBQUssZ0JBQUwsR0FBd0IsS0FBSyxJQUFMLENBQVUsS0FBSyxPQUFMLENBQWEscUJBQWIsR0FBcUMsTUFBckMsQ0FBbEMsQ0FERDtPQUFwQixNQUVPO0FBQ0wsMkJBQWtCLENBQUMsS0FBSyxnQkFBTCxDQURkO09BRlA7QUFLQSxVQUFJLGFBQWEsQ0FBQyxTQUFTLEtBQUssU0FBTCxDQUFlLEtBQWYsQ0FBcUIsVUFBckIsQ0FBVCxJQUE2QyxDQUE3QyxDQUFELEdBQW1ELGdCQUFuRCxDQVBXO0FBUTVCLFdBQUssU0FBTCxDQUFlLEtBQWYsQ0FBcUIsVUFBckIsR0FBa0MsYUFBYSxJQUFiLENBUk47Ozs7Ozs7Ozs2QkFjckI7QUFDUCxhQUNFOztVQUFLLE9BQU8sS0FBSyxLQUFMLENBQVcsS0FBWCxFQUFrQixXQUFXLEtBQUssS0FBTCxDQUFXLFNBQVgsRUFBekM7UUFDRyxLQUFLLEtBQUwsQ0FBVyxRQUFYO09BRkwsQ0FETzs7OztTQTFMTDtFQUFlLGdCQUFNLFNBQU47Ozs7Ozs7QUFzTXJCLE9BQU8sWUFBUCxHQUFzQjtBQUNwQixhQUFXLEVBQVg7QUFDQSxTQUFPLEVBQVA7QUFDQSxlQUFhLFFBQWI7QUFDQSxlQUFhLEVBQWI7QUFDQSxhQUFXLENBQVg7QUFDQSx1QkFBcUIsK0JBQVksRUFBWjtDQU52Qjs7a0JBU2U7Ozs7Ozs7Ozs7O1FDck5DO0FBQVQsU0FBUyxJQUFULENBQWMsSUFBZCxFQUFvQixNQUFwQixFQUE0QjtBQUNqQyxPQUFLLElBQUksSUFBSixJQUFZLE1BQWpCLEVBQXlCO0FBQ3ZCLFNBQUssSUFBTCxJQUFhLE9BQU8sSUFBUCxDQUFiLENBRHVCO0dBQXpCLENBRGlDO0FBSWpDLFNBQU8sSUFBUCxDQUppQztDQUE1Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0dQLElBQU0sUUFBUTtBQUNaLHFCQUFtQixLQUFuQjtBQUNBLGlCQUFlLEtBQWY7Q0FGSTs7QUFLTixJQUFNLFNBQVMsNEJBQVQ7Ozs7O0FBS04sQ0FBQyxRQUFELEVBQVcsUUFBWCxFQUFxQixXQUFyQixFQUFrQyxVQUFsQyxFQUNHLE9BREgsQ0FDVyxVQUFTLElBQVQsRUFBZTtBQUN0QixNQUFJLE9BQU8sZ0JBQVAsRUFBeUI7QUFDM0IsV0FBTyxnQkFBUCxDQUF3QixJQUF4QixFQUE4QixXQUE5QixFQUQyQjtHQUE3QixNQUVPO0FBQ0wsV0FBTyxXQUFQLENBQW1CLE9BQU8sSUFBUCxFQUFhLFdBQWhDLEVBREs7R0FGUDtDQURPLENBRFg7OztBQVdBLG1CQUFJLFNBQVMsSUFBVCxHQUFnQjtBQUNsQixNQUFJLE1BQU0saUJBQU4sSUFBMkIsTUFBTSxhQUFOLEVBQXFCO0FBQ2xELFlBQVEsR0FBUixDQUFZLFNBQVosRUFEa0Q7QUFFbEQsV0FBTyxJQUFQLEdBRmtEO0FBR2xELFVBQU0saUJBQU4sR0FBMEIsS0FBMUIsQ0FIa0Q7R0FBcEQ7QUFLQSxxQkFBSSxJQUFKLEVBTmtCO0NBQWhCLENBQUo7Ozs7Ozs7QUFlQSxTQUFTLFdBQVQsQ0FBcUIsS0FBckIsRUFBNEI7QUFDMUIsVUFBUSxNQUFNLElBQU47QUFDTixTQUFLLFdBQUw7QUFDRSxZQUFNLGFBQU4sR0FBc0IsSUFBdEIsQ0FERjtBQUVFLFlBRkY7QUFERixTQUlPLFVBQUw7QUFDRSxZQUFNLGFBQU4sR0FBc0IsS0FBdEIsQ0FERjtBQUVFLFlBRkY7QUFKRjtBQVFJLFlBQU0saUJBQU4sR0FBMEIsSUFBMUIsQ0FERjtBQVBGLEdBRDBCO0NBQTVCOztrQkFhZTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqRGYsaUJBQU8sU0FBUDs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJleHBvcnQgY29uc3QgU1RJQ0tZX0NPTlRBSU5FUl9BVFRSID0gJ2RhdGEtc3RpY2t5LWNvbnRhaW5lcic7XG4iLCJpbXBvcnQgeyBTVElDS1lfQ09OVEFJTkVSX0FUVFIgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbmNsYXNzIENvbnRhaW5lciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5zdGF0ZSA9IHt9XG4gICAgdGhpcy5zdGF0ZVtTVElDS1lfQ09OVEFJTkVSX0FUVFJdID0gJyc7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIDxkaXYgey4uLnRoaXMucHJvcHN9IHsuLi50aGlzLnN0YXRlfT57dGhpcy5wcm9wcy5jaGlsZHJlbn08L2Rpdj5cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb250YWluZXI7XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgeyBTVElDS1lfQ09OVEFJTkVSX0FUVFIgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgd2F0Y2hlciBmcm9tICcuL3dhdGNoZXInO1xuaW1wb3J0IHsgY29weSB9IGZyb20gJy4vdXRpbHMnO1xuXG5jbGFzcyBTdGlja3kgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXG4gIC8qXG4gICAqIFJldHVybiBldmVyeSBTdGlja3kgaW5zdGFuY2UgdGhhdCBpc1xuICAgKiBwb3NpdGlvbmVkIGFib3ZlIHRoZSBzdXBwbGllZCBpbnN0YW5jZS5cbiAgICovXG4gIHN0YXRpYyBpbnN0YW5jZXNBYm92ZShpbnN0YW5jZSkge1xuICAgIC8vIHZhciBpbnN0YW5jZXMgPSBbXTtcbiAgICAvLyB2YXIgYWxsQWJvdmUgPSBTdGlja3kuX19pbnN0YW5jZXMuc2xpY2UoMCwgU3RpY2t5Ll9faW5zdGFuY2VzLmluZGV4T2YoaW5zdGFuY2UpKTtcbiAgICAvLyBmb3IgKHZhciBpID0gMDsgaSA8IGFsbEFib3ZlLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gICB2YXIgYWJvdmUgPSBhbGxBYm92ZVtpXTtcbiAgICAvLyAgIGlmIChhYm92ZS5jb250YWluZXIuY29udGFpbnMoaW5zdGFuY2UuY29udGFpbmVyKSkgaW5zdGFuY2VzLnB1c2goYWJvdmUpO1xuICAgIC8vIH1cbiAgICByZXR1cm4gW107XG4gIH1cblxuXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuc3RhdGUgPSB7fTtcbiAgfVxuXG4gIC8qXG4gICAqIFJldHVybiB0aGUgZGlzdGFuY2Ugb2YgdGhlIHNjcm9sbGJhciBmcm9tIHRoZVxuICAgKiB0b3Agb2YgdGhlIHdpbmRvdyBwbHVzIHRoZSB0b3RhbCBoZWlnaHQgb2YgYWxsXG4gICAqIHN0dWNrIFN0aWNreSBpbnN0YW5jZXMgYWJvdmUgdGhpcyBvbmUuXG4gICAqL1xuICBwYWdlT2Zmc2V0KCkge1xuICAgIHJldHVybiAod2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3ApICsgdGhpcy5vdGhlclN0aWNreU9mZnNldCgpO1xuICB9XG5cbiAgb3RoZXJTdGlja3lPZmZzZXQoKSB7XG4gICAgdmFyIG90aGVyU3RpY2tpZXMgPSBTdGlja3kuaW5zdGFuY2VzQWJvdmUodGhpcyk7XG5cbiAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG90aGVyU3RpY2tpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBvdGhlclN0aWNreSA9IG90aGVyU3RpY2tpZXNbaV07XG4gICAgICBpZiAob3RoZXJTdGlja3kuc3RhdGUuaXNTdGlja3kpIHtcbiAgICAgICAgb2Zmc2V0ICs9IG90aGVyU3RpY2t5LmRvbU5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG5cbiAgY29udGFpbmVyT2Yobm9kZSkge1xuICAgIHZhciBjb250YWluZXIgPSBub2RlLnBhcmVudE5vZGUgfHwgZG9jdW1lbnQuYm9keTtcbiAgICB3aGlsZSAoY29udGFpbmVyICE9PSBkb2N1bWVudC5ib2R5XG4gICAgICAmJiAhY29udGFpbmVyLmhhc0F0dHJpYnV0ZShTVElDS1lfQ09OVEFJTkVSX0FUVFIpKSB7XG4gICAgICBjb250YWluZXIgPSBjb250YWluZXIucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfVxuXG4gIC8qXG4gICAqIFJldHVybnMgdGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgdG9wIG9mIHRoaXMgZWxlbWVudC5cbiAgICovXG4gIHRvcCgpIHtcbiAgICByZXR1cm4gdGhpcy5kb21Ob2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcbiAgfVxuXG4gIC8qXG4gICAqIFJldHVybnMgdHJ1ZS9mYWxzZSBkZXBlbmRpbmcgb24gaWYgdGhpcyBzaG91bGQgYmUgc3RpY2t5LlxuICAgKi9cbiAgc2hvdWxkQmVTdGlja3koKSB7XG4gICAgdmFyIG9mZnNldCA9IHRoaXMucGFnZU9mZnNldCgpXG4gICAgdmFyIHN0aWNreVRvcENvbmRpdGlvbnNNZXQgPSBvZmZzZXQgPj0gdGhpcy5vcmlnaW4gKyB0aGlzLnByb3BzLnRvcE9mZnNldDtcbiAgICB2YXIgc3RpY2t5Qm90dG9tQ29uZGl0aW9uc01ldCA9IHRoaXMuY29udGFpbmVyID09PSBkb2N1bWVudC5ib2R5ID8gdHJ1ZSA6IG9mZnNldCA8IHRoaXMuY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCArIHRoaXMub3JpZ2luIC0gdGhpcy5kb21Ob2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcblxuICAgIHJldHVybiBzdGlja3lUb3BDb25kaXRpb25zTWV0ICYmIHN0aWNreUJvdHRvbUNvbmRpdGlvbnNNZXQ7XG4gIH1cblxuXG4gIGhhbmRsZVVwZGF0ZSgpIHtcbiAgICBjb25zb2xlLmxvZygndXBkYXRpbmchJyk7XG4gICAgdmFyIHNob3VsZEJlU3RpY2t5ID0gdGhpcy5zaG91bGRCZVN0aWNreSgpO1xuICAgIHRoaXMubmV4dFN0YXRlKHNob3VsZEJlU3RpY2t5KTtcbiAgfVxuXG4gIC8qXG4gICAqIEFueXRpbWUgbmV3IHByb3BzIGFyZSByZWNlaXZlZCwgZm9yY2UgcmUtZXZhbHVhdGlvblxuICAgKi9cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpIHtcbiAgICB3YXRjaGVyLmVtaXQoKTtcbiAgfVxuXG4gIC8qXG4gICAqIEluc3RhbmNlIHdhcyBtb3VudGVkIG9uIHRoZSBwYWdlLlxuICAgKlxuICAgKiBJbiBvcmRlciwgdGhpcyBmdW5jdGlvbiBzaG91bGQ6XG4gICAqICAtIFJlZ2lzdGVyIGV2ZW50cyBsaXN0ZW5lcnMgd2l0aCB3aW5kb3cuXG4gICAqICAtIENhY2hlIHRoZSBkb21Ob2RlIHVzaW5nIFJlYWN0RE9NLmZpbmRET01Ob2RlLlxuICAgKiAgLSBTdG9yZSB0aGUgaW5pdGlhbCB5LXBvc2l0aW9uIChvcmlnaW4pIG9mIHRoaXNcbiAgICogICAgaW5zdGFuY2UuXG4gICAqICAtIFJlZ2lzdGVyIHRoaXMgaW5zdGFuY2UsIHN1YnNjcmliaW5nIHRvIGFuaW1hdGlvblxuICAgKiAgICBsb29wLlxuICAgKi9cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy5kb21Ob2RlID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcyk7XG4gICAgdGhpcy5jb250YWluZXIgPSB0aGlzLmNvbnRhaW5lck9mKHRoaXMuZG9tTm9kZSk7XG4gICAgdGhpcy5vcmlnaW4gPSB0aGlzLnRvcCgpICsgdGhpcy5wYWdlT2Zmc2V0KCk7XG5cbiAgICB3YXRjaGVyLm9uKHRoaXMuaGFuZGxlVXBkYXRlLmJpbmQodGhpcykpO1xuICAgIHdhdGNoZXIuZW1pdCgpO1xuICB9XG5cbiAgLypcbiAgICogSW5zdGFuY2Ugd2FzIHJlbW92ZWQgZnJvbSB0aGUgcGFnZS5cbiAgICpcbiAgICogVW5kbyBldmVyeXRoaW5nIGR1cmluZyBtb3VudGluZy5cbiAgICovXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMuZG9tTm9kZSA9IG51bGw7XG5cbiAgICB3YXRjaGVyLm9mZih0aGlzLmhhbmRsZVVwZGF0ZS5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIC8qXG4gICAqIElmIHN0aWNreSwgbWVyZ2UgdGhpcy5wcm9wcy5zdGlja3lTdHlsZSB3aXRoIHRoaXMucHJvcHMuc3R5bGUuXG4gICAqIElmIG5vdCwganVzdCByZXR1cm4gdGhpcy5wcm9wcy5zdHlsZS5cbiAgICovXG4gIG5leHRTdHlsZShzaG91bGRCZVN0aWNreSkge1xuICAgIGlmIChzaG91bGRCZVN0aWNreSkge1xuICAgICAgLy8gaW5oZXJpdCB0aGUgYm91bmRhcmllcyBvZiB0aGUgY29udGFpbmVyXG4gICAgICB2YXIgcmVjdCA9IHRoaXMuY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIHN0eWxlID0gY29weSh7fSwgdGhpcy5wcm9wcy5zdHlsZSk7XG4gICAgICBzdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgICBzdHlsZS5sZWZ0ID0gcmVjdC5sZWZ0O1xuICAgICAgc3R5bGUud2lkdGggPSByZWN0LndpZHRoO1xuICAgICAgc3R5bGUudG9wID0gdGhpcy5vdGhlclN0aWNreU9mZnNldCgpO1xuICAgICAgY29uc29sZS5sb2codGhpcy5kb21Ob2RlLCB0aGlzLmNvbnRhaW5lciwgdGhpcy5wYWdlT2Zmc2V0KCkpXG5cbiAgICAgIC8vIEZpbmFsbHksIG92ZXJyaWRlIHRoZSBiZXN0LWZpdCBzdHlsZSB3aXRoIGFueSB1c2VyIHByb3BzXG4gICAgICByZXR1cm4gY29weShzdHlsZSwgdGhpcy5wcm9wcy5zdGlja3lTdHlsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3BzLnN0eWxlO1xuICAgIH1cbiAgfVxuXG4gIC8qXG4gICAqIElmIHN0aWNreSwgbWVyZ2UgdGhpcy5wcm9wcy5zdGlja3lDbGFzcyB3aXRoIHRoaXMucHJvcHMuY2xhc3NOYW1lLlxuICAgKiBJZiBub3QsIGp1c3QgcmV0dXJuIHRoaXMucHJvcHMuY2xhc3NOYW1lLlxuICAgKi9cbiAgbmV4dENsYXNzTmFtZShzaG91bGRCZVN0aWNreSkge1xuICAgIHZhciBjbGFzc05hbWUgPSB0aGlzLnByb3BzLmNsYXNzTmFtZTtcbiAgICBpZiAoc2hvdWxkQmVTdGlja3kpIHtcbiAgICAgIGNsYXNzTmFtZSArPSAnICcgKyB0aGlzLnByb3BzLnN0aWNreUNsYXNzO1xuICAgIH1cbiAgICByZXR1cm4gY2xhc3NOYW1lO1xuICB9XG5cbiAgLypcbiAgICogVHJhbnNpdGlvbiB0byB0aGUgbmV4dCBzdGF0ZS5cbiAgICpcbiAgICogVXBkYXRlcyB0aGUgaXNTdGlja3ksIHN0eWxlLCBhbmQgY2xhc3NOYW1lIHN0YXRlXG4gICAqIHZhcmlhYmxlcy5cbiAgICpcbiAgICogSWYgc3RpY2t5IHN0YXRlIGlzIGRpZmZlcmVudCB0aGFuIHRoZSBwcmV2aW91cyxcbiAgICogZmlyZSB0aGUgb25TdGlja3lTdGF0ZUNoYW5nZSBjYWxsYmFjay5cbiAgICovXG4gIG5leHRTdGF0ZShzaG91bGRCZVN0aWNreSkge1xuICAgIHZhciBoYXNDaGFuZ2VkID0gdGhpcy5zdGF0ZS5pc1N0aWNreSAhPT0gc2hvdWxkQmVTdGlja3k7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBpc1N0aWNreTogc2hvdWxkQmVTdGlja3ksXG4gICAgICBzdHlsZTogdGhpcy5uZXh0U3R5bGUoc2hvdWxkQmVTdGlja3kpLFxuICAgICAgY2xhc3NOYW1lOiB0aGlzLm5leHRDbGFzc05hbWUoc2hvdWxkQmVTdGlja3kpXG4gICAgfSk7XG4gICAgaWYgKGhhc0NoYW5nZWQpIHtcbiAgICAgIHRoaXMuY29ycmVjdEJvdW5jZShzaG91bGRCZVN0aWNreSk7XG4gICAgICB0aGlzLnByb3BzLm9uU3RpY2t5U3RhdGVDaGFuZ2Uoc2hvdWxkQmVTdGlja3kpO1xuICAgIH1cbiAgfVxuXG4gIGNvcnJlY3RCb3VuY2Uoc2hvdWxkQmVTdGlja3kpIHtcbiAgICB2YXIgYm91bmNlQ29ycmVjdGlvbjtcbiAgICBpZiAoc2hvdWxkQmVTdGlja3kpIHtcbiAgICAgIGJvdW5jZUNvcnJlY3Rpb24gPSB0aGlzLmJvdW5jZUNvcnJlY3Rpb24gPSBNYXRoLmNlaWwodGhpcy5kb21Ob2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJvdW5jZUNvcnJlY3Rpb249IC10aGlzLmJvdW5jZUNvcnJlY3Rpb247XG4gICAgfVxuICAgIHZhciBwYWRkaW5nVG9wID0gKHBhcnNlSW50KHRoaXMuY29udGFpbmVyLnN0eWxlLnBhZGRpbmdUb3ApIHx8IDApICsgYm91bmNlQ29ycmVjdGlvbjtcbiAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS5wYWRkaW5nVG9wID0gcGFkZGluZ1RvcCArICdweCc7XG4gIH1cblxuICAvKlxuICAgKiBUaGUgc3BlY2lhbCBzYXVjZS5cbiAgICovXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBzdHlsZT17dGhpcy5zdGF0ZS5zdHlsZX0gY2xhc3NOYW1lPXt0aGlzLnN0YXRlLmNsYXNzTmFtZX0+XG4gICAgICAgIHt0aGlzLnByb3BzLmNoaWxkcmVufVxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuXG4vKlxuICogRGVmYXVsdCBwcm9wZXJ0aWVzLi4uXG4gKi9cblN0aWNreS5kZWZhdWx0UHJvcHMgPSB7XG4gIGNsYXNzTmFtZTogJycsXG4gIHN0eWxlOiB7fSxcbiAgc3RpY2t5Q2xhc3M6ICdzdGlja3knLFxuICBzdGlja3lTdHlsZToge30sXG4gIHRvcE9mZnNldDogMCxcbiAgb25TdGlja3lTdGF0ZUNoYW5nZTogZnVuY3Rpb24gKCkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgU3RpY2t5O1xuIiwiZXhwb3J0IGZ1bmN0aW9uIGNvcHkoZGVzdCwgc291cmNlKSB7XG4gIGZvciAodmFyIHJ1bGUgaW4gc291cmNlKSB7XG4gICAgZGVzdFtydWxlXSA9IHNvdXJjZVtydWxlXTtcbiAgfTtcbiAgcmV0dXJuIGRlc3Q7XG59XG4iLCJpbXBvcnQgcmFmIGZyb20gJ3JhZic7XG5pbXBvcnQgU2lnbmFsIGZyb20gJ3NpbXBsZS1zaWduYWwnO1xuXG5jb25zdCBzdGF0ZSA9IHtcbiAgaGFzVW5oYW5kbGVkRXZlbnQ6IGZhbHNlLFxuICBoYXNUb3VjaEV2ZW50OiBmYWxzZVxufTtcblxuY29uc3Qgc2lnbmFsID0gbmV3IFNpZ25hbCgpO1xuXG4vKipcbiAgKiBXaXJlIHVwIGV2ZW50IGxpc3RlbmVyc1xuICAqL1xuWydzY3JvbGwnLCAncmVzaXplJywgJ3RvdWNobW92ZScsICd0b3VjaGVuZCddXG4gIC5mb3JFYWNoKGZ1bmN0aW9uKHR5cGUpIHtcbiAgICBpZiAod2luZG93LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZUV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2luZG93LmF0dGFjaEV2ZW50KCdvbicgKyB0eXBlLCBoYW5kbGVFdmVudCk7XG4gICAgfVxuICB9KTtcblxuXG4vLyBTdGFydCB0aGUgbG9vcFxucmFmKGZ1bmN0aW9uIHRpY2soKSB7XG4gIGlmIChzdGF0ZS5oYXNVbmhhbmRsZWRFdmVudCB8fCBzdGF0ZS5oYXNUb3VjaEV2ZW50KSB7XG4gICAgY29uc29sZS5sb2coJ2VtaXR0ZXInKVxuICAgIHNpZ25hbC5lbWl0KCk7XG4gICAgc3RhdGUuaGFzVW5oYW5kbGVkRXZlbnQgPSBmYWxzZTtcbiAgfVxuICByYWYodGljayk7XG59KTtcblxuXG4vKlxuICogTGlnaHR3ZWlnaHQgZXZlbnQgbGlzdGVuZXIgZm9yIHdpbmRvdyBldmVudHMuXG4gKlxuICogU2VlIGh0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL3NwZWVkL2FuaW1hdGlvbnMvXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50KGV2ZW50KSB7XG4gIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgIGNhc2UgJ3RvdWNobW92ZSc6XG4gICAgICBzdGF0ZS5oYXNUb3VjaEV2ZW50ID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RvdWNoZW5kJzpcbiAgICAgIHN0YXRlLmhhc1RvdWNoRXZlbnQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5oYXNVbmhhbmRsZWRFdmVudCA9IHRydWU7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgc2lnbmFsO1xuIiwiaW1wb3J0IFN0aWNreSBmcm9tICcuL3N0aWNreSc7XG5pbXBvcnQgQ29udGFpbmVyIGZyb20gJy4vY29udGFpbmVyJztcblxuU3RpY2t5LkNvbnRhaW5lciA9IENvbnRhaW5lcjtcblxuZXhwb3J0IGRlZmF1bHQgU3RpY2t5O1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjcuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIgZ2V0TmFub1NlY29uZHMsIGhydGltZSwgbG9hZFRpbWU7XG5cbiAgaWYgKCh0eXBlb2YgcGVyZm9ybWFuY2UgIT09IFwidW5kZWZpbmVkXCIgJiYgcGVyZm9ybWFuY2UgIT09IG51bGwpICYmIHBlcmZvcm1hbmNlLm5vdykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgfTtcbiAgfSBlbHNlIGlmICgodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2VzcyAhPT0gbnVsbCkgJiYgcHJvY2Vzcy5ocnRpbWUpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIChnZXROYW5vU2Vjb25kcygpIC0gbG9hZFRpbWUpIC8gMWU2O1xuICAgIH07XG4gICAgaHJ0aW1lID0gcHJvY2Vzcy5ocnRpbWU7XG4gICAgZ2V0TmFub1NlY29uZHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBocjtcbiAgICAgIGhyID0gaHJ0aW1lKCk7XG4gICAgICByZXR1cm4gaHJbMF0gKiAxZTkgKyBoclsxXTtcbiAgICB9O1xuICAgIGxvYWRUaW1lID0gZ2V0TmFub1NlY29uZHMoKTtcbiAgfSBlbHNlIGlmIChEYXRlLm5vdykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gRGF0ZS5ub3coKSAtIGxvYWRUaW1lO1xuICAgIH07XG4gICAgbG9hZFRpbWUgPSBEYXRlLm5vdygpO1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBsb2FkVGltZTtcbiAgICB9O1xuICAgIGxvYWRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH1cblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBzZXRUaW1lb3V0KGRyYWluUXVldWUsIDApO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwidmFyIG5vdyA9IHJlcXVpcmUoJ3BlcmZvcm1hbmNlLW5vdycpXG4gICwgcm9vdCA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogd2luZG93XG4gICwgdmVuZG9ycyA9IFsnbW96JywgJ3dlYmtpdCddXG4gICwgc3VmZml4ID0gJ0FuaW1hdGlvbkZyYW1lJ1xuICAsIHJhZiA9IHJvb3RbJ3JlcXVlc3QnICsgc3VmZml4XVxuICAsIGNhZiA9IHJvb3RbJ2NhbmNlbCcgKyBzdWZmaXhdIHx8IHJvb3RbJ2NhbmNlbFJlcXVlc3QnICsgc3VmZml4XVxuXG5mb3IodmFyIGkgPSAwOyAhcmFmICYmIGkgPCB2ZW5kb3JzLmxlbmd0aDsgaSsrKSB7XG4gIHJhZiA9IHJvb3RbdmVuZG9yc1tpXSArICdSZXF1ZXN0JyArIHN1ZmZpeF1cbiAgY2FmID0gcm9vdFt2ZW5kb3JzW2ldICsgJ0NhbmNlbCcgKyBzdWZmaXhdXG4gICAgICB8fCByb290W3ZlbmRvcnNbaV0gKyAnQ2FuY2VsUmVxdWVzdCcgKyBzdWZmaXhdXG59XG5cbi8vIFNvbWUgdmVyc2lvbnMgb2YgRkYgaGF2ZSByQUYgYnV0IG5vdCBjQUZcbmlmKCFyYWYgfHwgIWNhZikge1xuICB2YXIgbGFzdCA9IDBcbiAgICAsIGlkID0gMFxuICAgICwgcXVldWUgPSBbXVxuICAgICwgZnJhbWVEdXJhdGlvbiA9IDEwMDAgLyA2MFxuXG4gIHJhZiA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgaWYocXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICB2YXIgX25vdyA9IG5vdygpXG4gICAgICAgICwgbmV4dCA9IE1hdGgubWF4KDAsIGZyYW1lRHVyYXRpb24gLSAoX25vdyAtIGxhc3QpKVxuICAgICAgbGFzdCA9IG5leHQgKyBfbm93XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY3AgPSBxdWV1ZS5zbGljZSgwKVxuICAgICAgICAvLyBDbGVhciBxdWV1ZSBoZXJlIHRvIHByZXZlbnRcbiAgICAgICAgLy8gY2FsbGJhY2tzIGZyb20gYXBwZW5kaW5nIGxpc3RlbmVyc1xuICAgICAgICAvLyB0byB0aGUgY3VycmVudCBmcmFtZSdzIHF1ZXVlXG4gICAgICAgIHF1ZXVlLmxlbmd0aCA9IDBcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGNwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYoIWNwW2ldLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgdHJ5e1xuICAgICAgICAgICAgICBjcFtpXS5jYWxsYmFjayhsYXN0KVxuICAgICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHRocm93IGUgfSwgMClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIE1hdGgucm91bmQobmV4dCkpXG4gICAgfVxuICAgIHF1ZXVlLnB1c2goe1xuICAgICAgaGFuZGxlOiArK2lkLFxuICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgY2FuY2VsbGVkOiBmYWxzZVxuICAgIH0pXG4gICAgcmV0dXJuIGlkXG4gIH1cblxuICBjYWYgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmKHF1ZXVlW2ldLmhhbmRsZSA9PT0gaGFuZGxlKSB7XG4gICAgICAgIHF1ZXVlW2ldLmNhbmNlbGxlZCA9IHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbikge1xuICAvLyBXcmFwIGluIGEgbmV3IGZ1bmN0aW9uIHRvIHByZXZlbnRcbiAgLy8gYGNhbmNlbGAgcG90ZW50aWFsbHkgYmVpbmcgYXNzaWduZWRcbiAgLy8gdG8gdGhlIG5hdGl2ZSByQUYgZnVuY3Rpb25cbiAgcmV0dXJuIHJhZi5jYWxsKHJvb3QsIGZuKVxufVxubW9kdWxlLmV4cG9ydHMuY2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gIGNhZi5hcHBseShyb290LCBhcmd1bWVudHMpXG59XG5tb2R1bGUuZXhwb3J0cy5wb2x5ZmlsbCA9IGZ1bmN0aW9uKCkge1xuICByb290LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHJhZlxuICByb290LmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gY2FmXG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gU2lnbmFsO1xuXG5mdW5jdGlvbiBTaWduYWwoKSB7XG4gIHZhciBzdWJzY3JpYmVycyA9IFtdO1xuICByZXR1cm4ge1xuICAgIG9uOiBmdW5jdGlvbiBvbihmbikge1xuICAgICAgc3Vic2NyaWJlcnMucHVzaChmbik7XG4gICAgfSxcbiAgICBvZmY6IGZ1bmN0aW9uIG9mZihmbikge1xuICAgICAgdmFyIGluZGV4ID0gc3Vic2NyaWJlcnMuaW5kZXhPZihmbik7XG4gICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICBzdWJzY3JpYmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZW1pdDogZnVuY3Rpb24gZW1pdCh2YWwpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzdWJzY3JpYmVycy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBzdWJzY3JpYmVyc1tpXSh2YWwpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTsiXX0=
