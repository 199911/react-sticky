(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Sticky = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = (typeof window !== "undefined" ? window['React'] : typeof global !== "undefined" ? global['React'] : null);

var _react2 = _interopRequireDefault(_react);

var _sticky = require('./sticky');

var _sticky2 = _interopRequireDefault(_sticky);

var _utils = require('./utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Container = function (_React$Component) {
  _inherits(Container, _React$Component);

  function Container(props) {
    _classCallCheck(this, Container);

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Container).call(this, props));

    _this.state = {
      topCorrection: 0
    };
    return _this;
  }

  _createClass(Container, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.setState({ node: ReactDOM.findDOMNode(this) });
    }
  }, {
    key: 'getChildContext',
    value: function getChildContext() {
      return {
        container: this
      };
    }
  }, {
    key: 'setTopCorrection',
    value: function setTopCorrection(topCorrection) {
      this.setState({ topCorrection: topCorrection });
    }
  }, {
    key: 'render',
    value: function render() {
      var style = (0, _utils.copy)({}, this.props.style || {});

      if (this.state.node) {
        var paddingTop = style.paddingTop || parseInt(this.state.node.style.paddingTop) || 0;
        style.paddingTop = paddingTop + this.state.topCorrection;
      }

      return _react2.default.createElement(
        'div',
        _extends({}, this.props, { style: style }),
        this.props.children
      );
    }
  }]);

  return Container;
}(_react2.default.Component);

Container.contextTypes = {
  container: _react2.default.PropTypes.any
};

Container.childContextTypes = {
  container: _react2.default.PropTypes.any
};

exports.default = Container;
module.exports = exports['default'];

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./sticky":2,"./utils":3}],2:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = (typeof window !== "undefined" ? window['React'] : typeof global !== "undefined" ? global['React'] : null);

var _react2 = _interopRequireDefault(_react);

var _reactDom = (typeof window !== "undefined" ? window['ReactDOM'] : typeof global !== "undefined" ? global['ReactDOM'] : null);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _watcher = require('./watcher');

var _watcher2 = _interopRequireDefault(_watcher);

var _utils = require('./utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Sticky = function (_React$Component) {
  _inherits(Sticky, _React$Component);

  function Sticky(props) {
    _classCallCheck(this, Sticky);

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Sticky).call(this, props));

    _this.state = {};
    return _this;
  }

  /*
   * Return the distance of the scrollbar from the
   * top of the window plus the total height of all
   * stuck Sticky instances above this one.
   */


  _createClass(Sticky, [{
    key: 'pageOffset',
    value: function pageOffset() {
      return window.pageYOffset || document.documentElement.scrollTop;
    }
  }, {
    key: 'otherStickyOffset',
    value: function otherStickyOffset() {
      var offset = 0;
      if (this.container) {
        var container = this.container.context.container;
        while (container) {
          offset = container.state.topCorrection;
          container = container.context.container;
        };
      }
      return offset;
    }

    /*
     * Returns the y-coordinate of the top of this element.
     */

  }, {
    key: 'calculateOrigin',
    value: function calculateOrigin(node) {
      node = node || this.node;

      // Only recalcute origin if the last origin has been made stale via resize
      if (this.lastWidth !== window.innerWidth || this.lastHeight !== window.innerHeight) {
        this.lastWidth = window.innerWidth;
        this.lastHeight = window.innerHeight;

        // Do some ugly DOM manipulation to where this element's non-sticky position would be
        var previousPosition = node.style.position;
        node.style.position = '';
        node.style.position;
        this.origin = node.getBoundingClientRect().top + this.pageOffset();
        node.style.position = previousPosition;
      }

      return this.origin;
    }

    /*
     * Returns true/false depending on if this should be sticky.
     */

  }, {
    key: 'shouldBeSticky',
    value: function shouldBeSticky() {
      var offset = this.pageOffset();
      var otherStickyOffset = this.otherStickyOffset();
      var origin = this.calculateOrigin() - otherStickyOffset;

      var stickyTopConditionsMet = offset >= origin + this.props.topOffset;
      var stickyBottomConditionsMet = offset < this.containerNode.getBoundingClientRect().height + origin - this.node.getBoundingClientRect().height;
      return stickyTopConditionsMet && stickyBottomConditionsMet;
    }
  }, {
    key: 'transition',
    value: function transition() {
      if (this.containerNode) {
        this.nextState(this.shouldBeSticky());
      }
    }

    /*
     * Anytime new props are received, force re-evaluation
     */

  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps() {
      _watcher2.default.emit();
    }
  }, {
    key: 'componentWillUpdate',
    value: function componentWillUpdate(props, state, context) {
      this.container = context.container;
      this.containerNode = _reactDom2.default.findDOMNode(this.container);
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.node = _reactDom2.default.findDOMNode(this);
      _watcher2.default.on(this.transition.bind(this));
      _watcher2.default.emit();
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      _watcher2.default.off(this.transition.bind(this));
    }

    /*
     * If sticky, merge this.props.stickyStyle with this.props.style.
     * If not, just return this.props.style.
     */

  }, {
    key: 'nextStyle',
    value: function nextStyle(shouldBeSticky) {
      if (shouldBeSticky) {
        // inherit the boundaries of the container
        var rect = (this.containerNode || document.body).getBoundingClientRect();
        var style = (0, _utils.copy)({}, this.props.style);
        style.position = 'fixed';
        style.left = rect.left;
        style.width = rect.width;
        style.top = this.otherStickyOffset();

        // Finally, override the best-fit style with any user props
        return (0, _utils.copy)(style, this.props.stickyStyle);
      } else {
        return this.props.style;
      }
    }

    /*
     * If sticky, merge this.props.stickyClass with this.props.className.
     * If not, just return this.props.className.
     */

  }, {
    key: 'nextClassName',
    value: function nextClassName(shouldBeSticky) {
      var className = this.props.className;
      if (shouldBeSticky) {
        className += ' ' + this.props.stickyClass;
      }
      return className;
    }

    /*
     * Transition to the next state.
     *
     * Updates the isSticky, style, and className state
     * variables.
     *
     * If sticky state is different than the previous,
     * fire the onStickyStateChange callback.
     */

  }, {
    key: 'nextState',
    value: function nextState(shouldBeSticky) {
      var hasChanged = this.state.isSticky !== shouldBeSticky;
      this.setState({
        isSticky: shouldBeSticky,
        style: this.nextStyle(shouldBeSticky),
        className: this.nextClassName(shouldBeSticky)
      });
      if (hasChanged) {
        this.preventBounce(shouldBeSticky);
        this.props.onStickyStateChange(shouldBeSticky);
      }
    }
  }, {
    key: 'preventBounce',
    value: function preventBounce(shouldBeSticky) {
      var bounceCorrection = undefined;
      if (shouldBeSticky) {
        bounceCorrection = this.bounceCorrection = Math.ceil(this.node.getBoundingClientRect().height);
      } else {
        bounceCorrection = -this.bounceCorrection || 0;
      }
      if (this.container) this.container.setTopCorrection(bounceCorrection);
    }

    /*
     * The special sauce.
     */

  }, {
    key: 'render',
    value: function render() {
      return _react2.default.createElement(
        'div',
        { style: this.state.style, className: this.state.className },
        this.props.children
      );
    }
  }]);

  return Sticky;
}(_react2.default.Component);

Sticky.contextTypes = {
  container: _react2.default.PropTypes.any
};

/*
 * Default properties...
 */
Sticky.defaultProps = {
  className: '',
  style: {},
  stickyClass: 'sticky',
  stickyStyle: {},
  topOffset: 0,
  onStickyStateChange: function onStickyStateChange() {}
};

exports.default = Sticky;
module.exports = exports['default'];

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./utils":3,"./watcher":4}],3:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.copy = copy;
exports.findStickies = findStickies;

var _react = (typeof window !== "undefined" ? window['React'] : typeof global !== "undefined" ? global['React'] : null);

var _sticky = require('./sticky');

var _sticky2 = _interopRequireDefault(_sticky);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function copy(dest, source) {
  for (var rule in source) {
    dest[rule] = source[rule];
  };
  return dest;
}

function findStickies(children) {
  var found = [];
  children.forEach(function (child) {
    if (child.type === _sticky2.default) found.push(child);
  });
  return found;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./sticky":2}],4:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _raf = require('raf');

var _raf2 = _interopRequireDefault(_raf);

var _simpleSignal = require('simple-signal');

var _simpleSignal2 = _interopRequireDefault(_simpleSignal);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var state = {
  hasUnhandledEvent: false,
  hasTouchEvent: false
};

var signal = new _simpleSignal2.default();

/**
  * Wire up event listeners
  */
['scroll', 'resize', 'touchmove', 'touchend'].forEach(function (evt) {
  if (window.addEventListener) {
    window.addEventListener(evt, handleEvent);
  } else {
    window.attachEvent('on' + evt, handleEvent);
  }
});

// Start the loop
(0, _raf2.default)(function tick() {
  if (state.hasUnhandledEvent || state.hasTouchEvent) {
    signal.emit();
    state.hasUnhandledEvent = false;
  }
  (0, _raf2.default)(tick);
});

function handleEvent(event) {
  switch (event.type) {
    case 'touchmove':
      state.hasTouchEvent = true;
      break;
    case 'touchend':
      state.hasTouchEvent = false;
      break;
    default:
      state.hasUnhandledEvent = true;
  }
}

exports.default = signal;
module.exports = exports['default'];

},{"raf":8,"simple-signal":9}],5:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _sticky = require('./sticky');

var _sticky2 = _interopRequireDefault(_sticky);

var _container = require('./container');

var _container2 = _interopRequireDefault(_container);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_sticky2.default.Container = _container2.default;

exports.default = _sticky2.default;
module.exports = exports['default'];

},{"./container":1,"./sticky":2}],6:[function(require,module,exports){
(function (process){
// Generated by CoffeeScript 1.7.1
(function() {
  var getNanoSeconds, hrtime, loadTime;

  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
    module.exports = function() {
      return performance.now();
    };
  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
    module.exports = function() {
      return (getNanoSeconds() - loadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    loadTime = getNanoSeconds();
  } else if (Date.now) {
    module.exports = function() {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    module.exports = function() {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }

}).call(this);

}).call(this,require('_process'))

},{"_process":7}],7:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],8:[function(require,module,exports){
(function (global){
var now = require('performance-now')
  , root = typeof window === 'undefined' ? global : window
  , vendors = ['moz', 'webkit']
  , suffix = 'AnimationFrame'
  , raf = root['request' + suffix]
  , caf = root['cancel' + suffix] || root['cancelRequest' + suffix]

for(var i = 0; !raf && i < vendors.length; i++) {
  raf = root[vendors[i] + 'Request' + suffix]
  caf = root[vendors[i] + 'Cancel' + suffix]
      || root[vendors[i] + 'CancelRequest' + suffix]
}

// Some versions of FF have rAF but not cAF
if(!raf || !caf) {
  var last = 0
    , id = 0
    , queue = []
    , frameDuration = 1000 / 60

  raf = function(callback) {
    if(queue.length === 0) {
      var _now = now()
        , next = Math.max(0, frameDuration - (_now - last))
      last = next + _now
      setTimeout(function() {
        var cp = queue.slice(0)
        // Clear queue here to prevent
        // callbacks from appending listeners
        // to the current frame's queue
        queue.length = 0
        for(var i = 0; i < cp.length; i++) {
          if(!cp[i].cancelled) {
            try{
              cp[i].callback(last)
            } catch(e) {
              setTimeout(function() { throw e }, 0)
            }
          }
        }
      }, Math.round(next))
    }
    queue.push({
      handle: ++id,
      callback: callback,
      cancelled: false
    })
    return id
  }

  caf = function(handle) {
    for(var i = 0; i < queue.length; i++) {
      if(queue[i].handle === handle) {
        queue[i].cancelled = true
      }
    }
  }
}

module.exports = function(fn) {
  // Wrap in a new function to prevent
  // `cancel` potentially being assigned
  // to the native rAF function
  return raf.call(root, fn)
}
module.exports.cancel = function() {
  caf.apply(root, arguments)
}
module.exports.polyfill = function() {
  root.requestAnimationFrame = raf
  root.cancelAnimationFrame = caf
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"performance-now":6}],9:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports["default"] = Signal;

function Signal() {
  var subscribers = [];
  return {
    on: function on(fn) {
      subscribers.push(fn);
    },
    off: function off(fn) {
      var index = subscribers.indexOf(fn);
      if (index > -1) {
        subscribers.splice(index, 1);
      }
    },
    emit: function emit(val) {
      for (var i = 0, len = subscribers.length; i < len; ++i) {
        subscribers[i](val);
      }
    }
  };
}

module.exports = exports["default"];
},{}]},{},[5])(5)
});
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJsaWIvY29udGFpbmVyLmpzIiwibGliL3N0aWNreS5qcyIsImxpYi91dGlscy5qcyIsImxpYi93YXRjaGVyLmpzIiwiaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGVyZm9ybWFuY2Utbm93L2xpYi9wZXJmb3JtYW5jZS1ub3cuanMiLCJub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JhZi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zaW1wbGUtc2lnbmFsL2xpYi9pbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lDSU07OztBQUNKLFdBREksU0FDSixDQUFZLEtBQVosRUFBbUI7MEJBRGYsV0FDZTs7dUVBRGYsc0JBRUksUUFEVzs7QUFFakIsVUFBSyxLQUFMLEdBQWE7QUFDWCxxQkFBZSxDQUFmO0tBREYsQ0FGaUI7O0dBQW5COztlQURJOzt3Q0FRZ0I7QUFDbEIsV0FBSyxRQUFMLENBQWMsRUFBRSxNQUFNLFNBQVMsV0FBVCxDQUFxQixJQUFyQixDQUFOLEVBQWhCLEVBRGtCOzs7O3NDQUlGO0FBQ2hCLGFBQU87QUFDTCxtQkFBVyxJQUFYO09BREYsQ0FEZ0I7Ozs7cUNBTUQsZUFBZTtBQUM5QixXQUFLLFFBQUwsQ0FBYyxFQUFFLDRCQUFGLEVBQWQsRUFEOEI7Ozs7NkJBSXZCO0FBQ1AsVUFBSSxRQUFRLGlCQUFLLEVBQUwsRUFBUyxLQUFLLEtBQUwsQ0FBVyxLQUFYLElBQW9CLEVBQXBCLENBQWpCLENBREc7O0FBR1AsVUFBSSxLQUFLLEtBQUwsQ0FBVyxJQUFYLEVBQWlCO0FBQ25CLFlBQUksYUFBYSxNQUFNLFVBQU4sSUFBcUIsU0FBUyxLQUFLLEtBQUwsQ0FBVyxJQUFYLENBQWdCLEtBQWhCLENBQXNCLFVBQXRCLENBQVQsSUFBOEMsQ0FBOUMsQ0FEbkI7QUFFbkIs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LE1BQU0sSUFBTjtBQUNOLFNBQUssV0FBTDtBQUNFLFlBQU0sYUFBTixHQUFzQixJQUF0QixDQURGO0FBRUUsWUFGRjtBQURGLFNBSU8sVUFBTDtBQUNFLFlBQU0sYUFBTixHQUFzQixLQUF0QixDQURGO0FBRUUsWUFGRjtBQUpGO0FBUUksWUFBTSxpQkFBTixHQUEwQixJQUExQixDQURGO0FBUEYsR0FEMEI7Q0FBNUI7O2tCQWFlOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzFDZixpQkFBTyxTQUFQOzs7Ozs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgU3RpY2t5IGZyb20gJy4vc3RpY2t5JztcbmltcG9ydCB7IGNvcHkgfSBmcm9tICcuL3V0aWxzJztcblxuY2xhc3MgQ29udGFpbmVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHRvcENvcnJlY3Rpb246IDBcbiAgICB9O1xuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IG5vZGU6IFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpIH0pO1xuICB9XG5cbiAgZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb250YWluZXI6IHRoaXNcbiAgICB9XG4gIH1cblxuICBzZXRUb3BDb3JyZWN0aW9uKHRvcENvcnJlY3Rpb24pIHtcbiAgICB0aGlzLnNldFN0YXRlKHsgdG9wQ29ycmVjdGlvbiB9KTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBsZXQgc3R5bGUgPSBjb3B5KHt9LCB0aGlzLnByb3BzLnN0eWxlIHx8IHt9KTtcblxuICAgIGlmICh0aGlzLnN0YXRlLm5vZGUpIHtcbiAgICAgIGxldCBwYWRkaW5nVG9wID0gc3R5bGUucGFkZGluZ1RvcCB8fCAocGFyc2VJbnQodGhpcy5zdGF0ZS5ub2RlLnN0eWxlLnBhZGRpbmdUb3ApIHx8IDApO1xuICAgICAgc3R5bGUucGFkZGluZ1RvcCA9IHBhZGRpbmdUb3AgKyB0aGlzLnN0YXRlLnRvcENvcnJlY3Rpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIDxkaXYgey4uLnRoaXMucHJvcHN9IHN0eWxlPXtzdHlsZX0+XG4gICAgICB7dGhpcy5wcm9wcy5jaGlsZHJlbn1cbiAgICA8L2Rpdj5cbiAgfVxufVxuXG5Db250YWluZXIuY29udGV4dFR5cGVzID0ge1xuICBjb250YWluZXI6IFJlYWN0LlByb3BUeXBlcy5hbnlcbn1cblxuQ29udGFpbmVyLmNoaWxkQ29udGV4dFR5cGVzID0ge1xuICBjb250YWluZXI6IFJlYWN0LlByb3BUeXBlcy5hbnlcbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29udGFpbmVyO1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IHdhdGNoZXIgZnJvbSAnLi93YXRjaGVyJztcbmltcG9ydCB7IGNvcHkgfSBmcm9tICcuL3V0aWxzJztcblxuY2xhc3MgU3RpY2t5IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblxuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0geyB9O1xuICB9XG5cbiAgLypcbiAgICogUmV0dXJuIHRoZSBkaXN0YW5jZSBvZiB0aGUgc2Nyb2xsYmFyIGZyb20gdGhlXG4gICAqIHRvcCBvZiB0aGUgd2luZG93IHBsdXMgdGhlIHRvdGFsIGhlaWdodCBvZiBhbGxcbiAgICogc3R1Y2sgU3RpY2t5IGluc3RhbmNlcyBhYm92ZSB0aGlzIG9uZS5cbiAgICovXG4gIHBhZ2VPZmZzZXQoKSB7XG4gICAgcmV0dXJuICh3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCk7XG4gIH1cblxuICBvdGhlclN0aWNreU9mZnNldCgpIHtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBpZiAodGhpcy5jb250YWluZXIpIHtcbiAgICAgIGxldCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lci5jb250ZXh0LmNvbnRhaW5lcjtcbiAgICAgIHdoaWxlIChjb250YWluZXIpIHtcbiAgICAgICAgb2Zmc2V0ID0gY29udGFpbmVyLnN0YXRlLnRvcENvcnJlY3Rpb247XG4gICAgICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lci5jb250ZXh0LmNvbnRhaW5lcjtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQ7XG4gIH1cblxuICAvKlxuICAgKiBSZXR1cm5zIHRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIHRvcCBvZiB0aGlzIGVsZW1lbnQuXG4gICAqL1xuICBjYWxjdWxhdGVPcmlnaW4obm9kZSkge1xuICAgIG5vZGUgPSBub2RlIHx8IHRoaXMubm9kZTtcblxuICAgIC8vIE9ubHkgcmVjYWxjdXRlIG9yaWdpbiBpZiB0aGUgbGFzdCBvcmlnaW4gaGFzIGJlZW4gbWFkZSBzdGFsZSB2aWEgcmVzaXplXG4gICAgaWYgKHRoaXMubGFzdFdpZHRoICE9PSB3aW5kb3cuaW5uZXJXaWR0aCB8fCB0aGlzLmxhc3RIZWlnaHQgIT09IHdpbmRvdy5pbm5lckhlaWdodCkge1xuICAgICAgdGhpcy5sYXN0V2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgIHRoaXMubGFzdEhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcblxuICAgICAgLy8gRG8gc29tZSB1Z2x5IERPTSBtYW5pcHVsYXRpb24gdG8gd2hlcmUgdGhpcyBlbGVtZW50J3Mgbm9uLXN0aWNreSBwb3NpdGlvbiB3b3VsZCBiZVxuICAgICAgbGV0IHByZXZpb3VzUG9zaXRpb24gPSBub2RlLnN0eWxlLnBvc2l0aW9uO1xuICAgICAgbm9kZS5zdHlsZS5wb3NpdGlvbiA9ICcnO1xuICAgICAgbm9kZS5zdHlsZS5wb3NpdGlvbjtcbiAgICAgIHRoaXMub3JpZ2luID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgKyB0aGlzLnBhZ2VPZmZzZXQoKTtcbiAgICAgIG5vZGUuc3R5bGUucG9zaXRpb24gPSBwcmV2aW91c1Bvc2l0aW9uO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm9yaWdpbjtcbiAgfVxuXG4gIC8qXG4gICAqIFJldHVybnMgdHJ1ZS9mYWxzZSBkZXBlbmRpbmcgb24gaWYgdGhpcyBzaG91bGQgYmUgc3RpY2t5LlxuICAgKi9cbiAgc2hvdWxkQmVTdGlja3koKSB7XG4gICAgbGV0IG9mZnNldCA9IHRoaXMucGFnZU9mZnNldCgpO1xuICAgIGxldCBvdGhlclN0aWNreU9mZnNldCA9IHRoaXMub3RoZXJTdGlja3lPZmZzZXQoKTtcbiAgICBsZXQgb3JpZ2luID0gdGhpcy5jYWxjdWxhdGVPcmlnaW4oKSAtIG90aGVyU3RpY2t5T2Zmc2V0O1xuXG4gICAgdmFyIHN0aWNreVRvcENvbmRpdGlvbnNNZXQgPSBvZmZzZXQgPj0gb3JpZ2luICsgdGhpcy5wcm9wcy50b3BPZmZzZXQ7XG4gICAgdmFyIHN0aWNreUJvdHRvbUNvbmRpdGlvbnNNZXQgPSBvZmZzZXQgPCB0aGlzLmNvbnRhaW5lck5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0ICsgb3JpZ2luIC0gdGhpcy5ub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgICByZXR1cm4gc3RpY2t5VG9wQ29uZGl0aW9uc01ldCAmJiBzdGlja3lCb3R0b21Db25kaXRpb25zTWV0O1xuICB9XG5cblxuICB0cmFuc2l0aW9uKCkge1xuICAgIGlmICh0aGlzLmNvbnRhaW5lck5vZGUpIHtcbiAgICAgIHRoaXMubmV4dFN0YXRlKHRoaXMuc2hvdWxkQmVTdGlja3koKSk7XG4gICAgfVxuICB9XG5cbiAgLypcbiAgICogQW55dGltZSBuZXcgcHJvcHMgYXJlIHJlY2VpdmVkLCBmb3JjZSByZS1ldmFsdWF0aW9uXG4gICAqL1xuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCkge1xuICAgIHdhdGNoZXIuZW1pdCgpO1xuICB9XG5cbiAgY29tcG9uZW50V2lsbFVwZGF0ZShwcm9wcywgc3RhdGUsIGNvbnRleHQpIHtcbiAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRleHQuY29udGFpbmVyO1xuICAgIHRoaXMuY29udGFpbmVyTm9kZSA9IFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMuY29udGFpbmVyKTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMubm9kZSA9IFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpO1xuICAgIHdhdGNoZXIub24odGhpcy50cmFuc2l0aW9uLmJpbmQodGhpcykpO1xuICAgIHdhdGNoZXIuZW1pdCgpO1xuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgd2F0Y2hlci5vZmYodGhpcy50cmFuc2l0aW9uLmJpbmQodGhpcykpO1xuICB9XG5cbiAgLypcbiAgICogSWYgc3RpY2t5LCBtZXJnZSB0aGlzLnByb3BzLnN0aWNreVN0eWxlIHdpdGggdGhpcy5wcm9wcy5zdHlsZS5cbiAgICogSWYgbm90LCBqdXN0IHJldHVybiB0aGlzLnByb3BzLnN0eWxlLlxuICAgKi9cbiAgbmV4dFN0eWxlKHNob3VsZEJlU3RpY2t5KSB7XG4gICAgaWYgKHNob3VsZEJlU3RpY2t5KSB7XG4gICAgICAvLyBpbmhlcml0IHRoZSBib3VuZGFyaWVzIG9mIHRoZSBjb250YWluZXJcbiAgICAgIHZhciByZWN0ID0gKHRoaXMuY29udGFpbmVyTm9kZSB8fCBkb2N1bWVudC5ib2R5KS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBzdHlsZSA9IGNvcHkoe30sIHRoaXMucHJvcHMuc3R5bGUpO1xuICAgICAgc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICAgICAgc3R5bGUubGVmdCA9IHJlY3QubGVmdDtcbiAgICAgIHN0eWxlLndpZHRoID0gcmVjdC53aWR0aDtcbiAgICAgIHN0eWxlLnRvcCA9IHRoaXMub3RoZXJTdGlja3lPZmZzZXQoKTtcblxuICAgICAgLy8gRmluYWxseSwgb3ZlcnJpZGUgdGhlIGJlc3QtZml0IHN0eWxlIHdpdGggYW55IHVzZXIgcHJvcHNcbiAgICAgIHJldHVybiBjb3B5KHN0eWxlLCB0aGlzLnByb3BzLnN0aWNreVN0eWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMucHJvcHMuc3R5bGU7XG4gICAgfVxuICB9XG5cbiAgLypcbiAgICogSWYgc3RpY2t5LCBtZXJnZSB0aGlzLnByb3BzLnN0aWNreUNsYXNzIHdpdGggdGhpcy5wcm9wcy5jbGFzc05hbWUuXG4gICAqIElmIG5vdCwganVzdCByZXR1cm4gdGhpcy5wcm9wcy5jbGFzc05hbWUuXG4gICAqL1xuICBuZXh0Q2xhc3NOYW1lKHNob3VsZEJlU3RpY2t5KSB7XG4gICAgdmFyIGNsYXNzTmFtZSA9IHRoaXMucHJvcHMuY2xhc3NOYW1lO1xuICAgIGlmIChzaG91bGRCZVN0aWNreSkge1xuICAgICAgY2xhc3NOYW1lICs9ICcgJyArIHRoaXMucHJvcHMuc3RpY2t5Q2xhc3M7XG4gICAgfVxuICAgIHJldHVybiBjbGFzc05hbWU7XG4gIH1cblxuICAvKlxuICAgKiBUcmFuc2l0aW9uIHRvIHRoZSBuZXh0IHN0YXRlLlxuICAgKlxuICAgKiBVcGRhdGVzIHRoZSBpc1N0aWNreSwgc3R5bGUsIGFuZCBjbGFzc05hbWUgc3RhdGVcbiAgICogdmFyaWFibGVzLlxuICAgKlxuICAgKiBJZiBzdGlja3kgc3RhdGUgaXMgZGlmZmVyZW50IHRoYW4gdGhlIHByZXZpb3VzLFxuICAgKiBmaXJlIHRoZSBvblN0aWNreVN0YXRlQ2hhbmdlIGNhbGxiYWNrLlxuICAgKi9cbiAgbmV4dFN0YXRlKHNob3VsZEJlU3RpY2t5KSB7XG4gICAgdmFyIGhhc0NoYW5nZWQgPSB0aGlzLnN0YXRlLmlzU3RpY2t5ICE9PSBzaG91bGRCZVN0aWNreTtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGlzU3RpY2t5OiBzaG91bGRCZVN0aWNreSxcbiAgICAgIHN0eWxlOiB0aGlzLm5leHRTdHlsZShzaG91bGRCZVN0aWNreSksXG4gICAgICBjbGFzc05hbWU6IHRoaXMubmV4dENsYXNzTmFtZShzaG91bGRCZVN0aWNreSlcbiAgICB9KTtcbiAgICBpZiAoaGFzQ2hhbmdlZCkge1xuICAgICAgdGhpcy5wcmV2ZW50Qm91bmNlKHNob3VsZEJlU3RpY2t5KTtcbiAgICAgIHRoaXMucHJvcHMub25TdGlja3lTdGF0ZUNoYW5nZShzaG91bGRCZVN0aWNreSk7XG4gICAgfVxuICB9XG5cbiAgcHJldmVudEJvdW5jZShzaG91bGRCZVN0aWNreSkge1xuICAgIGxldCBib3VuY2VDb3JyZWN0aW9uO1xuICAgIGlmIChzaG91bGRCZVN0aWNreSkge1xuICAgICAgYm91bmNlQ29ycmVjdGlvbiA9IHRoaXMuYm91bmNlQ29ycmVjdGlvbiA9IE1hdGguY2VpbCh0aGlzLm5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYm91bmNlQ29ycmVjdGlvbj0gLXRoaXMuYm91bmNlQ29ycmVjdGlvbiB8fCAwO1xuICAgIH1cbiAgICBpZiAodGhpcy5jb250YWluZXIpIHRoaXMuY29udGFpbmVyLnNldFRvcENvcnJlY3Rpb24oYm91bmNlQ29ycmVjdGlvbilcbiAgfVxuXG4gIC8qXG4gICAqIFRoZSBzcGVjaWFsIHNhdWNlLlxuICAgKi9cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IHN0eWxlPXt0aGlzLnN0YXRlLnN0eWxlfSBjbGFzc05hbWU9e3RoaXMuc3RhdGUuY2xhc3NOYW1lfT5cbiAgICAgICAge3RoaXMucHJvcHMuY2hpbGRyZW59XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG5cblN0aWNreS5jb250ZXh0VHlwZXMgPSB7XG4gIGNvbnRhaW5lcjogUmVhY3QuUHJvcFR5cGVzLmFueVxufVxuXG5cbi8qXG4gKiBEZWZhdWx0IHByb3BlcnRpZXMuLi5cbiAqL1xuU3RpY2t5LmRlZmF1bHRQcm9wcyA9IHtcbiAgY2xhc3NOYW1lOiAnJyxcbiAgc3R5bGU6IHt9LFxuICBzdGlja3lDbGFzczogJ3N0aWNreScsXG4gIHN0aWNreVN0eWxlOiB7fSxcbiAgdG9wT2Zmc2V0OiAwLFxuICBvblN0aWNreVN0YXRlQ2hhbmdlOiBmdW5jdGlvbiAoKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBTdGlja3k7XG4iLCJpbXBvcnQgeyBDaGlsZHJlbiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBTdGlja3kgZnJvbSAnLi9zdGlja3knO1xuXG5leHBvcnQgZnVuY3Rpb24gY29weShkZXN0LCBzb3VyY2UpIHtcbiAgZm9yICh2YXIgcnVsZSBpbiBzb3VyY2UpIHtcbiAgICBkZXN0W3J1bGVdID0gc291cmNlW3J1bGVdO1xuICB9O1xuICByZXR1cm4gZGVzdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRTdGlja2llcyhjaGlsZHJlbikge1xuICBsZXQgZm91bmQgPSBbXTtcbiAgY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICBpZiAoY2hpbGQudHlwZSA9PT0gU3RpY2t5KSBmb3VuZC5wdXNoKGNoaWxkKTtcbiAgfSk7XG4gIHJldHVybiBmb3VuZDtcbn1cbiIsImltcG9ydCByYWYgZnJvbSAncmFmJztcbmltcG9ydCBTaWduYWwgZnJvbSAnc2ltcGxlLXNpZ25hbCc7XG5cbmNvbnN0IHN0YXRlID0ge1xuICBoYXNVbmhhbmRsZWRFdmVudDogZmFsc2UsXG4gIGhhc1RvdWNoRXZlbnQ6IGZhbHNlXG59O1xuXG5jb25zdCBzaWduYWwgPSBuZXcgU2lnbmFsKCk7XG5cbi8qKlxuICAqIFdpcmUgdXAgZXZlbnQgbGlzdGVuZXJzXG4gICovXG5bJ3Njcm9sbCcsICdyZXNpemUnLCAndG91Y2htb3ZlJywgJ3RvdWNoZW5kJ11cbiAgLmZvckVhY2goZnVuY3Rpb24oZXZ0KSB7XG4gICAgaWYgKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihldnQsIGhhbmRsZUV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2luZG93LmF0dGFjaEV2ZW50KCdvbicgKyBldnQsIGhhbmRsZUV2ZW50KTtcbiAgICB9XG4gIH0pO1xuXG5cbi8vIFN0YXJ0IHRoZSBsb29wXG5yYWYoZnVuY3Rpb24gdGljaygpIHtcbiAgaWYgKHN0YXRlLmhhc1VuaGFuZGxlZEV2ZW50IHx8IHN0YXRlLmhhc1RvdWNoRXZlbnQpIHtcbiAgICBzaWduYWwuZW1pdCgpO1xuICAgIHN0YXRlLmhhc1VuaGFuZGxlZEV2ZW50ID0gZmFsc2U7XG4gIH1cbiAgcmFmKHRpY2spO1xufSk7XG5cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50KGV2ZW50KSB7XG4gIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgIGNhc2UgJ3RvdWNobW92ZSc6XG4gICAgICBzdGF0ZS5oYXNUb3VjaEV2ZW50ID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RvdWNoZW5kJzpcbiAgICAgIHN0YXRlLmhhc1RvdWNoRXZlbnQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5oYXNVbmhhbmRsZWRFdmVudCA9IHRydWU7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgc2lnbmFsO1xuIiwiaW1wb3J0IFN0aWNreSBmcm9tICcuL3N0aWNreSc7XG5pbXBvcnQgQ29udGFpbmVyIGZyb20gJy4vY29udGFpbmVyJztcblxuU3RpY2t5LkNvbnRhaW5lciA9IENvbnRhaW5lcjtcblxuZXhwb3J0IGRlZmF1bHQgU3RpY2t5O1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjcuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIgZ2V0TmFub1NlY29uZHMsIGhydGltZSwgbG9hZFRpbWU7XG5cbiAgaWYgKCh0eXBlb2YgcGVyZm9ybWFuY2UgIT09IFwidW5kZWZpbmVkXCIgJiYgcGVyZm9ybWFuY2UgIT09IG51bGwpICYmIHBlcmZvcm1hbmNlLm5vdykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgfTtcbiAgfSBlbHNlIGlmICgodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2VzcyAhPT0gbnVsbCkgJiYgcHJvY2Vzcy5ocnRpbWUpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIChnZXROYW5vU2Vjb25kcygpIC0gbG9hZFRpbWUpIC8gMWU2O1xuICAgIH07XG4gICAgaHJ0aW1lID0gcHJvY2Vzcy5ocnRpbWU7XG4gICAgZ2V0TmFub1NlY29uZHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBocjtcbiAgICAgIGhyID0gaHJ0aW1lKCk7XG4gICAgICByZXR1cm4gaHJbMF0gKiAxZTkgKyBoclsxXTtcbiAgICB9O1xuICAgIGxvYWRUaW1lID0gZ2V0TmFub1NlY29uZHMoKTtcbiAgfSBlbHNlIGlmIChEYXRlLm5vdykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gRGF0ZS5ub3coKSAtIGxvYWRUaW1lO1xuICAgIH07XG4gICAgbG9hZFRpbWUgPSBEYXRlLm5vdygpO1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBsb2FkVGltZTtcbiAgICB9O1xuICAgIGxvYWRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH1cblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBzZXRUaW1lb3V0KGRyYWluUXVldWUsIDApO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwidmFyIG5vdyA9IHJlcXVpcmUoJ3BlcmZvcm1hbmNlLW5vdycpXG4gICwgcm9vdCA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogd2luZG93XG4gICwgdmVuZG9ycyA9IFsnbW96JywgJ3dlYmtpdCddXG4gICwgc3VmZml4ID0gJ0FuaW1hdGlvbkZyYW1lJ1xuICAsIHJhZiA9IHJvb3RbJ3JlcXVlc3QnICsgc3VmZml4XVxuICAsIGNhZiA9IHJvb3RbJ2NhbmNlbCcgKyBzdWZmaXhdIHx8IHJvb3RbJ2NhbmNlbFJlcXVlc3QnICsgc3VmZml4XVxuXG5mb3IodmFyIGkgPSAwOyAhcmFmICYmIGkgPCB2ZW5kb3JzLmxlbmd0aDsgaSsrKSB7XG4gIHJhZiA9IHJvb3RbdmVuZG9yc1tpXSArICdSZXF1ZXN0JyArIHN1ZmZpeF1cbiAgY2FmID0gcm9vdFt2ZW5kb3JzW2ldICsgJ0NhbmNlbCcgKyBzdWZmaXhdXG4gICAgICB8fCByb290W3ZlbmRvcnNbaV0gKyAnQ2FuY2VsUmVxdWVzdCcgKyBzdWZmaXhdXG59XG5cbi8vIFNvbWUgdmVyc2lvbnMgb2YgRkYgaGF2ZSByQUYgYnV0IG5vdCBjQUZcbmlmKCFyYWYgfHwgIWNhZikge1xuICB2YXIgbGFzdCA9IDBcbiAgICAsIGlkID0gMFxuICAgICwgcXVldWUgPSBbXVxuICAgICwgZnJhbWVEdXJhdGlvbiA9IDEwMDAgLyA2MFxuXG4gIHJhZiA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgaWYocXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICB2YXIgX25vdyA9IG5vdygpXG4gICAgICAgICwgbmV4dCA9IE1hdGgubWF4KDAsIGZyYW1lRHVyYXRpb24gLSAoX25vdyAtIGxhc3QpKVxuICAgICAgbGFzdCA9IG5leHQgKyBfbm93XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY3AgPSBxdWV1ZS5zbGljZSgwKVxuICAgICAgICAvLyBDbGVhciBxdWV1ZSBoZXJlIHRvIHByZXZlbnRcbiAgICAgICAgLy8gY2FsbGJhY2tzIGZyb20gYXBwZW5kaW5nIGxpc3RlbmVyc1xuICAgICAgICAvLyB0byB0aGUgY3VycmVudCBmcmFtZSdzIHF1ZXVlXG4gICAgICAgIHF1ZXVlLmxlbmd0aCA9IDBcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGNwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYoIWNwW2ldLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgdHJ5e1xuICAgICAgICAgICAgICBjcFtpXS5jYWxsYmFjayhsYXN0KVxuICAgICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHRocm93IGUgfSwgMClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIE1hdGgucm91bmQobmV4dCkpXG4gICAgfVxuICAgIHF1ZXVlLnB1c2goe1xuICAgICAgaGFuZGxlOiArK2lkLFxuICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgY2FuY2VsbGVkOiBmYWxzZVxuICAgIH0pXG4gICAgcmV0dXJuIGlkXG4gIH1cblxuICBjYWYgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmKHF1ZXVlW2ldLmhhbmRsZSA9PT0gaGFuZGxlKSB7XG4gICAgICAgIHF1ZXVlW2ldLmNhbmNlbGxlZCA9IHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbikge1xuICAvLyBXcmFwIGluIGEgbmV3IGZ1bmN0aW9uIHRvIHByZXZlbnRcbiAgLy8gYGNhbmNlbGAgcG90ZW50aWFsbHkgYmVpbmcgYXNzaWduZWRcbiAgLy8gdG8gdGhlIG5hdGl2ZSByQUYgZnVuY3Rpb25cbiAgcmV0dXJuIHJhZi5jYWxsKHJvb3QsIGZuKVxufVxubW9kdWxlLmV4cG9ydHMuY2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gIGNhZi5hcHBseShyb290LCBhcmd1bWVudHMpXG59XG5tb2R1bGUuZXhwb3J0cy5wb2x5ZmlsbCA9IGZ1bmN0aW9uKCkge1xuICByb290LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHJhZlxuICByb290LmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gY2FmXG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gU2lnbmFsO1xuXG5mdW5jdGlvbiBTaWduYWwoKSB7XG4gIHZhciBzdWJzY3JpYmVycyA9IFtdO1xuICByZXR1cm4ge1xuICAgIG9uOiBmdW5jdGlvbiBvbihmbikge1xuICAgICAgc3Vic2NyaWJlcnMucHVzaChmbik7XG4gICAgfSxcbiAgICBvZmY6IGZ1bmN0aW9uIG9mZihmbikge1xuICAgICAgdmFyIGluZGV4ID0gc3Vic2NyaWJlcnMuaW5kZXhPZihmbik7XG4gICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICBzdWJzY3JpYmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZW1pdDogZnVuY3Rpb24gZW1pdCh2YWwpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzdWJzY3JpYmVycy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBzdWJzY3JpYmVyc1tpXSh2YWwpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTsiXX0=
