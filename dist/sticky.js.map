{"version":3,"sources":["node_modules/browser-pack/_prelude.js","lib/sticky.js","lib/utils.js"],"names":["React","window","global","ReactDOM","utils","require","Sticky","createClass","statics","__frame","__instances","register","instance","push","sort","a","b","top","resumeLoop","unregister","index","indexOf","splice","length","cancelLoop","instancesAbove","instances","allAbove","slice","i","above","container","contains","isModernBrowser","requestAnimationFrame","cancelAnimationFrame","nextFrame","setTimeout","onFrame","cancel","clearTimeout","sticky","handleFrame","getDefaultProps","type","DOM","div","className","style","stickyClass","stickyContainerClass","stickyStyle","topOffset","onStickyStateChange","getInitialState","events","pageOffset","pageYOffset","document","documentElement","scrollTop","this","otherStickyOffset","otherStickies","offset","otherSticky","state","isSticky","domNode","getBoundingClientRect","height","containerOf","node","parentNode","body","props","shouldBeSticky","stickyTopConditionsMet","origin","stickyBottomConditionsMet","hasUnhandledEvent","hasTouchEvent","nextState","handleEvent","event","componentDidMount","forEach","addEventListener","attachEvent","findDOMNode","componentWillReceiveProps","componentWillUnmount","removeEventListener","detachEvent","nextStyle","rect","copy","position","left","width","nextClassName","hasChanged","setState","correctBounce","bounceCorrection","Math","ceil","paddingTop","parseInt","render","children","module","exports","dest","source","rule","isDescendantOf","x","y","isAncestor"],"mappings":"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","file":"bundle.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","var React = (typeof window !== \"undefined\" ? window['React'] : typeof global !== \"undefined\" ? global['React'] : null);\nvar ReactDOM = (typeof window !== \"undefined\" ? window['ReactDOM'] : typeof global !== \"undefined\" ? global['ReactDOM'] : null);\nvar utils = require('./utils');\n\nvar Sticky = React.createClass({\n  /*\n   * Using statics to facilitate positional awareness\n   * between multiple Sticky instances residing in the\n   * DOM at the same time.\n   */\n  statics: {\n    /*\n     * Internal variables. Should not be used beyond\n     * the scope of other statics methods or testing.\n     */\n    __frame: null,\n    __instances: [],\n    /*\n     * Adds the supplied Sticky instance to the\n     * internal list of mounted Sticky instances,\n     * sorted by the .top() value for each instance.\n     *\n     * If the animation frame loop (or fallback)\n     * isn't running, start it now.\n     */\n    register: function(instance) {\n      Sticky.__instances.push(instance);\n      Sticky.__instances.sort(function(a, b) {\n        if (a.top() > b.top()) return 1;\n        if (b.top() > a.top()) return -1;\n        return 0;\n      });\n      if (Sticky.__frame === null) Sticky.resumeLoop();\n    },\n    /*\n     * Remove the supplied Sticky instance from the\n     * internal list of mounted Sticky instances.\n     *\n     * If the animation frame loop (or fallback)\n     * is no longer in use, stop it now.\n     */\n    unregister: function(instance) {\n      var index = Sticky.__instances.indexOf(instance);\n      if (index > -1) Sticky.__instances.splice(index, 1);\n      if (Sticky.__instances.length === 0) Sticky.cancelLoop();\n    },\n    /*\n     * Return every Sticky instance that is\n     * positioned above the supplied instance.\n     */\n    instancesAbove: function(instance) {\n      var instances = [];\n      var allAbove = Sticky.__instances.slice(0, Sticky.__instances.indexOf(instance));\n      for (var i = 0; i < allAbove.length; i++) {\n        var above = allAbove[i];\n        if (above.container.contains(instance.container)) instances.push(above);\n      }\n      return instances;\n    },\n    /*\n     * Returns true if the browser environment can support\n     * requestAnimationFrame. Otherwise returns false;\n     */\n    isModernBrowser: function() {\n      return window && window.requestAnimationFrame && window.cancelAnimationFrame;\n    },\n    /*\n     * Creates the next frame in the animation loop.\n     */\n    resumeLoop: function() {\n      var nextFrame = Sticky.isModernBrowser() ? requestAnimationFrame : setTimeout;\n      Sticky.__frame = nextFrame(Sticky.onFrame, 1000 / 60);\n    },\n    /*\n     * Cancels the animation loop.\n     */\n    cancelLoop: function() {\n      var cancel = Sticky.isModernBrowser() ? cancelAnimationFrame : clearTimeout;\n      cancel(Sticky.__frame);\n      Sticky.__frame = null;\n    },\n    /*\n     * Loop iteration routine.\n     */\n    onFrame: function() {\n      for (var i = 0; i < Sticky.__instances.length; i++) {\n        var sticky = Sticky.__instances[i];\n        sticky.handleFrame();\n      }\n      Sticky.resumeLoop();\n    }\n  },\n  /*\n   * Default properties. Self-explanatory...\n   */\n  getDefaultProps: function() {\n    return {\n      type: React.DOM.div,\n      className: '',\n      style: {},\n      stickyClass: 'sticky',\n      stickyContainerClass: 'sticky-container',\n      stickyStyle: {},\n      topOffset: 0,\n      onStickyStateChange: function () {}\n    };\n  },\n  /*\n   * Return the list of events this instance\n   * should react to.\n   */\n  getInitialState: function() {\n    return {\n      events: ['scroll', 'resize', 'touchmove', 'touchend']\n    };\n  },\n  /*\n   * Return the distance of the scrollbar from the\n   * top of the window plus the total height of all\n   * stuck Sticky instances above this one.\n   */\n  pageOffset: function() {\n    return (window.pageYOffset || document.documentElement.scrollTop) + this.otherStickyOffset();\n  },\n\n  otherStickyOffset: function() {\n    var otherStickies = Sticky.instancesAbove(this);\n\n    var offset = 0;\n    for (var i = 0; i < otherStickies.length; i++) {\n      var otherSticky = otherStickies[i];\n      if (otherSticky.state.isSticky) {\n        offset += otherSticky.domNode.getBoundingClientRect().height;\n      }\n    }\n    return offset;\n  },\n\n  containerOf: function(node) {\n    var container = node.parentNode || document.body;\n    while (container !== document.body\n      && container.className.indexOf(this.props.stickyContainerClass) < 0) {\n      container = container.parentNode;\n    }\n    return container;\n  },\n  /*\n   * Returns the y-coordinate of the top of this element.\n   */\n  top: function() {\n    return this.domNode.getBoundingClientRect().top;\n  },\n  /*\n   * Returns true/false depending on if this should be sticky.\n   */\n  shouldBeSticky: function() {\n    var offset = this.pageOffset()\n    var stickyTopConditionsMet = offset >= this.origin + this.props.topOffset;\n    var stickyBottomConditionsMet = this.container === document.body ? true : offset < this.container.getBoundingClientRect().height + this.origin - this.domNode.getBoundingClientRect().height;\n\n    return stickyTopConditionsMet && stickyBottomConditionsMet;\n  },\n  /*\n   * Loop iteration for this instance.\n   *\n   * Should only fire any time there is an event\n   * that hasn't been handled. This serves as a\n   * throttle for continuous events (i.e. scroll).\n   */\n  handleFrame: function() {\n    if (this.hasUnhandledEvent || this.hasTouchEvent) {\n      var shouldBeSticky = this.shouldBeSticky();\n      this.nextState(shouldBeSticky);\n      this.hasUnhandledEvent = false;\n    }\n  },\n  /*\n   * Lightweight event listener for window events.\n   *\n   * See http://www.html5rocks.com/en/tutorials/speed/animations/\n   */\n  handleEvent: function(event) {\n    switch (event.type) {\n      case 'touchmove':\n        this.hasTouchEvent = true;\n        break;\n      case 'touchend':\n        this.hasTouchEvent = false;\n        break;\n      default:\n        this.hasUnhandledEvent = true;\n    }\n  },\n  /*\n   * Instance was mounted on the page.\n   *\n   * In order, this function should:\n   *  - Register events listeners with window.\n   *  - Cache the domNode using ReactDOM.findDOMNode.\n   *  - Store the initial y-position (origin) of this\n   *    instance.\n   *  - Register this instance, subscribing to animation\n   *    loop.\n   */\n  componentDidMount: function() {\n    this.state.events.forEach(function(type) {\n      if (window.addEventListener) {\n        window.addEventListener(type, this.handleEvent);\n      } else {\n        window.attachEvent('on' + type, this.handleEvent);\n      }\n    }, this);\n    this.domNode = ReactDOM.findDOMNode(this);\n    this.container = this.containerOf(this.domNode);\n    this.origin = this.top() + this.pageOffset();\n    this.hasUnhandledEvent = true;\n    Sticky.register(this);\n  },\n\n  /*\n   * Anytime new props are received, force re-evaluation\n   */\n  componentWillReceiveProps: function() {\n    this.hasUnhandledEvent = true;\n  },\n  /*\n   * Instance was removed from the page.\n   *\n   * Undo everything during mounting.\n   */\n  componentWillUnmount: function() {\n    this.state.events.forEach(function(type) {\n      if (window.removeEventListener) {\n        window.removeEventListener(type, this.handleEvent);\n      } else {\n        window.detachEvent('on' + type, this.handleEvent)\n      }\n    }, this);\n    this.domNode = null;\n    Sticky.unregister(this);\n  },\n  /*\n   * If sticky, merge this.props.stickyStyle with this.props.style.\n   * If not, just return this.props.style.\n   */\n  nextStyle: function(shouldBeSticky) {\n    if (shouldBeSticky) {\n      // inherit the boundaries of the container\n      var rect = this.container.getBoundingClientRect();\n      var style = utils.copy({}, this.props.style);\n      style.position = 'fixed';\n      style.left = rect.left;\n      style.width = rect.width;\n      style.top = this.otherStickyOffset();\n\n      // Finally, override the best-fit style with any user props\n      return utils.copy(style, this.props.stickyStyle);\n    } else {\n      return this.props.style;\n    }\n  },\n  /*\n   * If sticky, merge this.props.stickyClass with this.props.className.\n   * If not, just return this.props.className.\n   */\n  nextClassName: function(shouldBeSticky) {\n    var className = this.props.className;\n    if (shouldBeSticky) {\n      className += ' ' + this.props.stickyClass;\n    }\n    return className;\n  },\n  /*\n   * Transition to the next state.\n   *\n   * Updates the isSticky, style, and className state\n   * variables.\n   *\n   * If sticky state is different than the previous,\n   * fire the onStickyStateChange callback.\n   */\n  nextState: function(shouldBeSticky) {\n    var hasChanged = this.state.isSticky !== shouldBeSticky;\n    this.setState({\n      isSticky: shouldBeSticky,\n      style: this.nextStyle(shouldBeSticky),\n      className: this.nextClassName(shouldBeSticky)\n    });\n    if (hasChanged) {\n      this.correctBounce(shouldBeSticky);\n      this.props.onStickyStateChange(shouldBeSticky);\n    }\n  },\n  correctBounce: function(shouldBeSticky) {\n    var bounceCorrection;\n    if (shouldBeSticky) {\n      bounceCorrection = this.bounceCorrection = Math.ceil(this.domNode.getBoundingClientRect().height);\n    } else {\n      bounceCorrection= -this.bounceCorrection;\n    }\n    var paddingTop = (parseInt(this.container.style.paddingTop) || 0) + bounceCorrection;\n    this.container.style.paddingTop = paddingTop + 'px';\n  },\n  /*\n   * The special sauce.\n   */\n  render: function() {\n    return this.props.type({\n      style: this.state.style,\n      className: this.state.className\n    }, this.props.children);\n  }\n});\n\nmodule.exports = Sticky;\n","module.exports = {\n  copy: function(dest, source) {\n    for (var rule in source) {\n      dest[rule] = source[rule];\n    };\n    return dest;\n  },\n  isDescendantOf: function(x, y) {\n    var isAncestor = false;\n\n    return isAncestor;\n  }\n}\n"]}