{"version":3,"sources":["node_modules/browser-pack/_prelude.js","lib","lib/sticky.js","lib/container.js","lib/utils.js"],"names":["Sticky","_React$Component","props","call","this","_this","state","events","instance","window","requestAnimationFrame","cancelAnimationFrame","pageYOffset","document","documentElement","scrollTop","otherStickyOffset","otherStickies","instancesAbove","offset","i","length","otherSticky","isSticky","domNode","getBoundingClientRect","height","node","container","parentNode","body","hasAttribute","top","pageOffset","stickyTopConditionsMet","origin","topOffset","stickyBottomConditionsMet","hasUnhandledEvent","hasTouchEvent","shouldBeSticky","nextState","event","type","rect","style","_utils","copy","position","left","width","console","log","stickyStyle","className","stickyClass","hasChanged","setState","nextStyle","nextClassName","correctBounce","onStickyStateChange","bounceCorrection","Math","ceil","paddingTop","parseInt","_react2","createElement","children","Component","defaultProps","Container","React","data-sticky-container","dest","source","rule"],"mappings":"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","file":"bundle.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","\"use strict\";function _interopRequireDefault(e){return e&&e.__esModule?e:{\"default\":e}}Object.defineProperty(exports,\"__esModule\",{value:!0});var _sticky=require(\"./sticky\"),_sticky2=_interopRequireDefault(_sticky),_container=require(\"./container\"),_container2=_interopRequireDefault(_container);_sticky2[\"default\"].Container=_container2[\"default\"],exports[\"default\"]=_sticky2[\"default\"],module.exports=exports[\"default\"];","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { copy } from './utils';\n\nclass Sticky extends React.Component {\n  /*\n   * Adds the supplied Sticky instance to the\n   * internal list of mounted Sticky instances,\n   * sorted by the .top() value for each instance.\n   *\n   * If the animation frame loop (or fallback)\n   * isn't running, start it now.\n   */\n   static register(instance) {\n    // Sticky.__instances.push(instance);\n    // Sticky.__instances.sort(function(a, b) {\n    //   if (a.top() > b.top()) return 1;\n    //   if (b.top() > a.top()) return -1;\n    //   return 0;\n    // });\n    // if (Sticky.__frame === null) Sticky.resumeLoop();\n  }\n\n  /*\n   * Remove the supplied Sticky instance from the\n   * internal list of mounted Sticky instances.\n   *\n   * If the animation frame loop (or fallback)\n   * is no longer in use, stop it now.\n   */\n  static unregister(instance) {\n    // var index = Sticky.__instances.indexOf(instance);\n    // if (index > -1) Sticky.__instances.splice(index, 1);\n    // if (Sticky.__instances.length === 0) Sticky.cancelLoop();\n  }\n\n  /*\n   * Return every Sticky instance that is\n   * positioned above the supplied instance.\n   */\n  static instancesAbove(instance) {\n    // var instances = [];\n    // var allAbove = Sticky.__instances.slice(0, Sticky.__instances.indexOf(instance));\n    // for (var i = 0; i < allAbove.length; i++) {\n    //   var above = allAbove[i];\n    //   if (above.container.contains(instance.container)) instances.push(above);\n    // }\n    // return instances;\n  }\n\n  /*\n   * Returns true if the browser environment can support\n   * requestAnimationFrame. Otherwise returns false;\n   */\n  static isModernBrowser() {\n    return window && window.requestAnimationFrame && window.cancelAnimationFrame;\n  }\n\n  /*\n   * Creates the next frame in the animation loop.\n   */\n  static resumeLoop() {\n    // var nextFrame = Sticky.isModernBrowser() ? requestAnimationFrame : setTimeout;\n    // Sticky.__frame = nextFrame(Sticky.onFrame, 1000 / 60);\n  }\n\n  /*\n   * Cancels the animation loop.\n   */\n  static cancelLoop() {\n    // var cancel = Sticky.isModernBrowser() ? cancelAnimationFrame : clearTimeout;\n    // cancel(Sticky.__frame);\n    // Sticky.__frame = null;\n  }\n\n  /*\n   * Loop iteration routine.\n   */\n  static onFrame() {\n    // for (var i = 0; i < Sticky.__instances.length; i++) {\n    //   var sticky = Sticky.__instances[i];\n    //   sticky.handleFrame();\n    // }\n    // Sticky.resumeLoop();\n  }\n\n  constructor(props) {\n    super(props);\n    this.state = {\n      events: ['scroll', 'resize', 'touchmove', 'touchend']\n    };\n  }\n\n  /*\n   * Return the distance of the scrollbar from the\n   * top of the window plus the total height of all\n   * stuck Sticky instances above this one.\n   */\n  pageOffset() {\n    return (window.pageYOffset || document.documentElement.scrollTop) + this.otherStickyOffset();\n  }\n\n  otherStickyOffset() {\n    var otherStickies = Sticky.instancesAbove(this);\n\n    var offset = 0;\n    for (var i = 0; i < otherStickies.length; i++) {\n      var otherSticky = otherStickies[i];\n      if (otherSticky.state.isSticky) {\n        offset += otherSticky.domNode.getBoundingClientRect().height;\n      }\n    }\n    return offset;\n  }\n\n  containerOf(node) {\n    var container = node.parentNode || document.body;\n    while (container !== document.body\n      && !container.hasAttribute('data-sticky-container')) {\n      container = container.parentNode;\n    }\n    return container;\n  }\n\n  /*\n   * Returns the y-coordinate of the top of this element.\n   */\n  top() {\n    return this.domNode.getBoundingClientRect().top;\n  }\n\n  /*\n   * Returns true/false depending on if this should be sticky.\n   */\n  shouldBeSticky() {\n    var offset = this.pageOffset()\n    var stickyTopConditionsMet = offset >= this.origin + this.props.topOffset;\n    var stickyBottomConditionsMet = this.container === document.body ? true : offset < this.container.getBoundingClientRect().height + this.origin - this.domNode.getBoundingClientRect().height;\n\n    return stickyTopConditionsMet && stickyBottomConditionsMet;\n  }\n\n  /*\n   * Loop iteration for this instance.\n   *\n   * Should only fire any time there is an event\n   * that hasn't been handled. This serves as a\n   * throttle for continuous events (i.e. scroll).\n   */\n  handleFrame() {\n    if (this.hasUnhandledEvent || this.hasTouchEvent) {\n      var shouldBeSticky = this.shouldBeSticky();\n      this.nextState(shouldBeSticky);\n      this.hasUnhandledEvent = false;\n    }\n  }\n\n  /*\n   * Lightweight event listener for window events.\n   *\n   * See http://www.html5rocks.com/en/tutorials/speed/animations/\n   */\n  handleEvent(event) {\n    switch (event.type) {\n      case 'touchmove':\n        this.hasTouchEvent = true;\n        break;\n      case 'touchend':\n        this.hasTouchEvent = false;\n        break;\n      default:\n        this.hasUnhandledEvent = true;\n    }\n  }\n\n  /*\n   * Instance was mounted on the page.\n   *\n   * In order, this function should:\n   *  - Register events listeners with window.\n   *  - Cache the domNode using ReactDOM.findDOMNode.\n   *  - Store the initial y-position (origin) of this\n   *    instance.\n   *  - Register this instance, subscribing to animation\n   *    loop.\n   */\n  componentDidMount() {\n    // this.state.events.forEach(function(type) {\n    //   if (window.addEventListener) {\n    //     window.addEventListener(type, this.handleEvent);\n    //   } else {\n    //     window.attachEvent('on' + type, this.handleEvent);\n    //   }\n    // }, this);\n    // this.domNode = ReactDOM.findDOMNode(this);\n    // this.container = this.containerOf(this.domNode);\n    // this.origin = this.top() + this.pageOffset();\n    // this.hasUnhandledEvent = true;\n    // Sticky.register(this);\n  }\n\n  /*\n   * Anytime new props are received, force re-evaluation\n   */\n  componentWillReceiveProps() {\n    this.hasUnhandledEvent = true;\n  }\n\n  /*\n   * Instance was removed from the page.\n   *\n   * Undo everything during mounting.\n   */\n  componentWillUnmount() {\n    // this.state.events.forEach(function(type) {\n    //   if (window.removeEventListener) {\n    //     window.removeEventListener(type, this.handleEvent);\n    //   } else {\n    //     window.detachEvent('on' + type, this.handleEvent)\n    //   }\n    // }, this);\n    // this.domNode = null;\n    // Sticky.unregister(this);\n  }\n\n  /*\n   * If sticky, merge this.props.stickyStyle with this.props.style.\n   * If not, just return this.props.style.\n   */\n  nextStyle(shouldBeSticky) {\n    if (shouldBeSticky) {\n      // inherit the boundaries of the container\n      var rect = this.container.getBoundingClientRect();\n      var style = copy({}, this.props.style);\n      style.position = 'fixed';\n      style.left = rect.left;\n      style.width = rect.width;\n      style.top = this.otherStickyOffset();\n      console.log(this.domNode, this.container, this.pageOffset())\n\n      // Finally, override the best-fit style with any user props\n      return copy(style, this.props.stickyStyle);\n    } else {\n      return this.props.style;\n    }\n  }\n\n  /*\n   * If sticky, merge this.props.stickyClass with this.props.className.\n   * If not, just return this.props.className.\n   */\n  nextClassName(shouldBeSticky) {\n    var className = this.props.className;\n    if (shouldBeSticky) {\n      className += ' ' + this.props.stickyClass;\n    }\n    return className;\n  }\n\n  /*\n   * Transition to the next state.\n   *\n   * Updates the isSticky, style, and className state\n   * variables.\n   *\n   * If sticky state is different than the previous,\n   * fire the onStickyStateChange callback.\n   */\n  nextState(shouldBeSticky) {\n    var hasChanged = this.state.isSticky !== shouldBeSticky;\n    this.setState({\n      isSticky: shouldBeSticky,\n      style: this.nextStyle(shouldBeSticky),\n      className: this.nextClassName(shouldBeSticky)\n    });\n    if (hasChanged) {\n      this.correctBounce(shouldBeSticky);\n      this.props.onStickyStateChange(shouldBeSticky);\n    }\n  }\n\n  correctBounce(shouldBeSticky) {\n    var bounceCorrection;\n    if (shouldBeSticky) {\n      bounceCorrection = this.bounceCorrection = Math.ceil(this.domNode.getBoundingClientRect().height);\n    } else {\n      bounceCorrection= -this.bounceCorrection;\n    }\n    var paddingTop = (parseInt(this.container.style.paddingTop) || 0) + bounceCorrection;\n    this.container.style.paddingTop = paddingTop + 'px';\n  }\n\n  /*\n   * The special sauce.\n   */\n  render() {\n    return (\n      <div style={this.state.style} className={this.state.className}>\n        {this.props.children}\n      </div>\n    );\n  }\n}\n\n/*\n * Default properties...\n */\nSticky.defaultProps = {\n  className: '',\n  style: {},\n  stickyClass: 'sticky',\n  stickyStyle: {},\n  topOffset: 0,\n  onStickyStateChange: function () {}\n}\n\nexport default Sticky;\n","class Container extends React.Component {\n\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n    return <div {...this.props} data-sticky-container>{this.props.children}</div>\n  }\n}\n\nexport default Container;\n","export function copy(dest, source) {\n  for (var rule in source) {\n    dest[rule] = source[rule];\n  };\n  return dest;\n}\n"]}