{"version":3,"sources":["node_modules/browser-pack/_prelude.js","lib","lib/sticky.js","lib/container.js","lib/utils.js","lib/timer.js","lib/constants.js","node_modules/raf/index.js","node_modules/simple-signal/lib/index.js","node_modules/performance-now/lib/performance-now.js","node_modules/process/browser.js"],"names":["Sticky","_React$Component","props","call","this","_this","state","events","instance","window","pageYOffset","document","documentElement","scrollTop","otherStickyOffset","otherStickies","instancesAbove","offset","i","length","otherSticky","isSticky","domNode","getBoundingClientRect","height","node","container","parentNode","body","hasAttribute","_constants","STICKY_CONTAINER_ATTR","top","pageOffset","stickyTopConditionsMet","origin","topOffset","stickyBottomConditionsMet","hasUnhandledEvent","hasTouchEvent","shouldBeSticky","nextState","event","type","forEach","addEventListener","handleEvent","attachEvent","_reactDom2","findDOMNode","containerOf","_timer2","on","handleFrame","removeEventListener","detachEvent","off","rect","style","_utils","copy","position","left","width","console","log","stickyStyle","className","stickyClass","hasChanged","setState","nextStyle","nextClassName","correctBounce","onStickyStateChange","bounceCorrection","Math","ceil","paddingTop","parseInt","_react2","createElement","children","Component","defaultProps","Container","React","dest","source","rule","timer","_simpleSignal2","_raf2","tick","emit","exports","now","require","root","global","vendors","suffix","raf","caf","last","id","queue","frameDuration","callback","_now","next","max","setTimeout","cp","slice","cancelled","e","round","push","handle","module","fn","cancel","apply","arguments","polyfill","requestAnimationFrame","cancelAnimationFrame","Signal","subscribers","index","indexOf","splice","val","len","__esModule","getNanoSeconds","hrtime","loadTime","performance","process","hr","Date","getTime","cleanUpNextTick","draining","currentQueue","concat","queueIndex","drainQueue","timeout","run","clearTimeout","Item","fun","array","noop","nextTick","args","Array","prototype","title","browser","env","argv","version","versions","addListener","once","removeListener","removeAllListeners","binding","name","Error","cwd","chdir","dir","umask"],"mappings":"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","file":"bundle.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","\"use strict\";function _interopRequireDefault(e){return e&&e.__esModule?e:{\"default\":e}}Object.defineProperty(exports,\"__esModule\",{value:!0});var _sticky=require(\"./sticky\"),_sticky2=_interopRequireDefault(_sticky),_container=require(\"./container\"),_container2=_interopRequireDefault(_container);_sticky2[\"default\"].Container=_container2[\"default\"],exports[\"default\"]=_sticky2[\"default\"],module.exports=exports[\"default\"];","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { STICKY_CONTAINER_ATTR } from './constants';\nimport { copy } from './utils';\nimport timer from './timer';\n\nclass Sticky extends React.Component {\n\n  /*\n   * Adds the supplied Sticky instance to the\n   * internal list of mounted Sticky instances,\n   * sorted by the .top() value for each instance.\n   *\n   * If the animation frame loop (or fallback)\n   * isn't running, start it now.\n   */\n   static register(instance) {\n    // Sticky.__instances.push(instance);\n    // Sticky.__instances.sort(function(a, b) {\n    //   if (a.top() > b.top()) return 1;\n    //   if (b.top() > a.top()) return -1;\n    //   return 0;\n    // });\n  }\n\n  /*\n   * Remove the supplied Sticky instance from the\n   * internal list of mounted Sticky instances.\n   *\n   * If the animation frame loop (or fallback)\n   * is no longer in use, stop it now.\n   */\n  static unregister(instance) {\n    // var index = Sticky.__instances.indexOf(instance);\n    // if (index > -1) Sticky.__instances.splice(index, 1);\n  }\n\n  /*\n   * Return every Sticky instance that is\n   * positioned above the supplied instance.\n   */\n  static instancesAbove(instance) {\n    // var instances = [];\n    // var allAbove = Sticky.__instances.slice(0, Sticky.__instances.indexOf(instance));\n    // for (var i = 0; i < allAbove.length; i++) {\n    //   var above = allAbove[i];\n    //   if (above.container.contains(instance.container)) instances.push(above);\n    // }\n    // return instances;\n  }\n\n  constructor(props) {\n    super(props);\n    this.state = {\n      events: ['scroll', 'resize', 'touchmove', 'touchend']\n    };\n  }\n\n  /*\n   * Return the distance of the scrollbar from the\n   * top of the window plus the total height of all\n   * stuck Sticky instances above this one.\n   */\n  pageOffset() {\n    return (window.pageYOffset || document.documentElement.scrollTop) + this.otherStickyOffset();\n  }\n\n  otherStickyOffset() {\n    var otherStickies = Sticky.instancesAbove(this);\n\n    var offset = 0;\n    for (var i = 0; i < otherStickies.length; i++) {\n      var otherSticky = otherStickies[i];\n      if (otherSticky.state.isSticky) {\n        offset += otherSticky.domNode.getBoundingClientRect().height;\n      }\n    }\n    return offset;\n  }\n\n  containerOf(node) {\n    var container = node.parentNode || document.body;\n    while (container !== document.body\n      && !container.hasAttribute(STICKY_CONTAINER_ATTR)) {\n      container = container.parentNode;\n    }\n    return container;\n  }\n\n  /*\n   * Returns the y-coordinate of the top of this element.\n   */\n  top() {\n    return this.domNode.getBoundingClientRect().top;\n  }\n\n  /*\n   * Returns true/false depending on if this should be sticky.\n   */\n  shouldBeSticky() {\n    var offset = this.pageOffset()\n    var stickyTopConditionsMet = offset >= this.origin + this.props.topOffset;\n    var stickyBottomConditionsMet = this.container === document.body ? true : offset < this.container.getBoundingClientRect().height + this.origin - this.domNode.getBoundingClientRect().height;\n\n    return stickyTopConditionsMet && stickyBottomConditionsMet;\n  }\n\n  /*\n   * Loop iteration for this instance.\n   *\n   * Should only fire any time there is an event\n   * that hasn't been handled. This serves as a\n   * throttle for continuous events (i.e. scroll).\n   */\n  handleFrame() {\n    if (this.hasUnhandledEvent || this.hasTouchEvent) {\n      var shouldBeSticky = this.shouldBeSticky();\n      this.nextState(shouldBeSticky);\n      this.hasUnhandledEvent = false;\n    }\n  }\n\n  /*\n   * Lightweight event listener for window events.\n   *\n   * See http://www.html5rocks.com/en/tutorials/speed/animations/\n   */\n  handleEvent(event) {\n    switch (event.type) {\n      case 'touchmove':\n        this.hasTouchEvent = true;\n        break;\n      case 'touchend':\n        this.hasTouchEvent = false;\n        break;\n      default:\n        this.hasUnhandledEvent = true;\n    }\n  }\n\n\n  /*\n   * Anytime new props are received, force re-evaluation\n   */\n  componentWillReceiveProps() {\n    this.hasUnhandledEvent = true;\n  }\n\n  /*\n   * Instance was mounted on the page.\n   *\n   * In order, this function should:\n   *  - Register events listeners with window.\n   *  - Cache the domNode using ReactDOM.findDOMNode.\n   *  - Store the initial y-position (origin) of this\n   *    instance.\n   *  - Register this instance, subscribing to animation\n   *    loop.\n   */\n  componentDidMount() {\n    this.state.events.forEach(function(type) {\n      if (window.addEventListener) {\n        window.addEventListener(type, this.handleEvent);\n      } else {\n        window.attachEvent('on' + type, this.handleEvent);\n      }\n    }, this);\n    this.domNode = ReactDOM.findDOMNode(this);\n    this.container = this.containerOf(this.domNode);\n    this.origin = this.top() + this.pageOffset();\n    this.hasUnhandledEvent = true;\n\n    timer.on(this.handleFrame);\n  }\n\n  /*\n   * Instance was removed from the page.\n   *\n   * Undo everything during mounting.\n   */\n  componentWillUnmount() {\n    this.state.events.forEach(function(type) {\n      if (window.removeEventListener) {\n        window.removeEventListener(type, this.handleEvent);\n      } else {\n        window.detachEvent('on' + type, this.handleEvent)\n      }\n    }, this);\n    this.domNode = null;\n\n    timer.off(this.handleFrame);\n  }\n\n  /*\n   * If sticky, merge this.props.stickyStyle with this.props.style.\n   * If not, just return this.props.style.\n   */\n  nextStyle(shouldBeSticky) {\n    if (shouldBeSticky) {\n      // inherit the boundaries of the container\n      var rect = this.container.getBoundingClientRect();\n      var style = copy({}, this.props.style);\n      style.position = 'fixed';\n      style.left = rect.left;\n      style.width = rect.width;\n      style.top = this.otherStickyOffset();\n      console.log(this.domNode, this.container, this.pageOffset())\n\n      // Finally, override the best-fit style with any user props\n      return copy(style, this.props.stickyStyle);\n    } else {\n      return this.props.style;\n    }\n  }\n\n  /*\n   * If sticky, merge this.props.stickyClass with this.props.className.\n   * If not, just return this.props.className.\n   */\n  nextClassName(shouldBeSticky) {\n    var className = this.props.className;\n    if (shouldBeSticky) {\n      className += ' ' + this.props.stickyClass;\n    }\n    return className;\n  }\n\n  /*\n   * Transition to the next state.\n   *\n   * Updates the isSticky, style, and className state\n   * variables.\n   *\n   * If sticky state is different than the previous,\n   * fire the onStickyStateChange callback.\n   */\n  nextState(shouldBeSticky) {\n    var hasChanged = this.state.isSticky !== shouldBeSticky;\n    this.setState({\n      isSticky: shouldBeSticky,\n      style: this.nextStyle(shouldBeSticky),\n      className: this.nextClassName(shouldBeSticky)\n    });\n    if (hasChanged) {\n      this.correctBounce(shouldBeSticky);\n      this.props.onStickyStateChange(shouldBeSticky);\n    }\n  }\n\n  correctBounce(shouldBeSticky) {\n    var bounceCorrection;\n    if (shouldBeSticky) {\n      bounceCorrection = this.bounceCorrection = Math.ceil(this.domNode.getBoundingClientRect().height);\n    } else {\n      bounceCorrection= -this.bounceCorrection;\n    }\n    var paddingTop = (parseInt(this.container.style.paddingTop) || 0) + bounceCorrection;\n    this.container.style.paddingTop = paddingTop + 'px';\n  }\n\n  /*\n   * The special sauce.\n   */\n  render() {\n    return (\n      <div style={this.state.style} className={this.state.className}>\n        {this.props.children}\n      </div>\n    );\n  }\n}\n\n/*\n * Default properties...\n */\nSticky.defaultProps = {\n  className: '',\n  style: {},\n  stickyClass: 'sticky',\n  stickyStyle: {},\n  topOffset: 0,\n  onStickyStateChange: function () {}\n}\n\nexport default Sticky;\n","import { STICKY_CONTAINER_ATTR } from './constants';\n\nclass Container extends React.Component {\n\n  constructor(props) {\n    super(props);\n    this.state = {}\n    this.state[STICKY_CONTAINER_ATTR] = '';\n  }\n\n  render() {\n    return <div {...this.props} {...this.state}>{this.props.children}</div>\n  }\n}\n\nexport default Container;\n","export function copy(dest, source) {\n  for (var rule in source) {\n    dest[rule] = source[rule];\n  };\n  return dest;\n}\n","import raf from 'raf';\nimport Signal from 'simple-signal';\n\nconst timer = new Signal();\n\nraf(function tick() {\n  timer.emit();\n  raf(tick);\n});\n\nexport default timer;\n","export const STICKY_CONTAINER_ATTR = 'data-sticky-container';\n","var now = require('performance-now')\n  , root = typeof window === 'undefined' ? global : window\n  , vendors = ['moz', 'webkit']\n  , suffix = 'AnimationFrame'\n  , raf = root['request' + suffix]\n  , caf = root['cancel' + suffix] || root['cancelRequest' + suffix]\n\nfor(var i = 0; !raf && i < vendors.length; i++) {\n  raf = root[vendors[i] + 'Request' + suffix]\n  caf = root[vendors[i] + 'Cancel' + suffix]\n      || root[vendors[i] + 'CancelRequest' + suffix]\n}\n\n// Some versions of FF have rAF but not cAF\nif(!raf || !caf) {\n  var last = 0\n    , id = 0\n    , queue = []\n    , frameDuration = 1000 / 60\n\n  raf = function(callback) {\n    if(queue.length === 0) {\n      var _now = now()\n        , next = Math.max(0, frameDuration - (_now - last))\n      last = next + _now\n      setTimeout(function() {\n        var cp = queue.slice(0)\n        // Clear queue here to prevent\n        // callbacks from appending listeners\n        // to the current frame's queue\n        queue.length = 0\n        for(var i = 0; i < cp.length; i++) {\n          if(!cp[i].cancelled) {\n            try{\n              cp[i].callback(last)\n            } catch(e) {\n              setTimeout(function() { throw e }, 0)\n            }\n          }\n        }\n      }, Math.round(next))\n    }\n    queue.push({\n      handle: ++id,\n      callback: callback,\n      cancelled: false\n    })\n    return id\n  }\n\n  caf = function(handle) {\n    for(var i = 0; i < queue.length; i++) {\n      if(queue[i].handle === handle) {\n        queue[i].cancelled = true\n      }\n    }\n  }\n}\n\nmodule.exports = function(fn) {\n  // Wrap in a new function to prevent\n  // `cancel` potentially being assigned\n  // to the native rAF function\n  return raf.call(root, fn)\n}\nmodule.exports.cancel = function() {\n  caf.apply(root, arguments)\n}\nmodule.exports.polyfill = function() {\n  root.requestAnimationFrame = raf\n  root.cancelAnimationFrame = caf\n}\n","\"use strict\";\n\nexports.__esModule = true;\nexports[\"default\"] = Signal;\n\nfunction Signal() {\n  var subscribers = [];\n  return {\n    on: function on(fn) {\n      subscribers.push(fn);\n    },\n    off: function off(fn) {\n      var index = subscribers.indexOf(fn);\n      if (index > -1) {\n        subscribers.splice(index, 1);\n      }\n    },\n    emit: function emit(val) {\n      for (var i = 0, len = subscribers.length; i < len; ++i) {\n        subscribers[i](val);\n      }\n    }\n  };\n}\n\nmodule.exports = exports[\"default\"];","// Generated by CoffeeScript 1.7.1\n(function() {\n  var getNanoSeconds, hrtime, loadTime;\n\n  if ((typeof performance !== \"undefined\" && performance !== null) && performance.now) {\n    module.exports = function() {\n      return performance.now();\n    };\n  } else if ((typeof process !== \"undefined\" && process !== null) && process.hrtime) {\n    module.exports = function() {\n      return (getNanoSeconds() - loadTime) / 1e6;\n    };\n    hrtime = process.hrtime;\n    getNanoSeconds = function() {\n      var hr;\n      hr = hrtime();\n      return hr[0] * 1e9 + hr[1];\n    };\n    loadTime = getNanoSeconds();\n  } else if (Date.now) {\n    module.exports = function() {\n      return Date.now() - loadTime;\n    };\n    loadTime = Date.now();\n  } else {\n    module.exports = function() {\n      return new Date().getTime() - loadTime;\n    };\n    loadTime = new Date().getTime();\n  }\n\n}).call(this);\n","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n"]}