{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","lib/sticky.js"],"names":["React","require","Sticky","createClass","statics","__frame","__instances","register","instance","push","sort","a","b","top","resumeLoop","unregister","index","indexOf","splice","length","cancelLoop","instancesAbove","slice","isModernBrowser","window","requestAnimationFrame","cancelAnimationFrame","nextFrame","setTimeout","onFrame","cancel","clearTimeout","i","sticky","handleFrame","getDefaultProps","type","DOM","div","className","style","stickyClass","stickyStyle","position","left","right","zIndex","topOffset","onStickyStateChange","getInitialState","events","pageOffset","otherStickies","this","otherStickyOffsets","otherSticky","state","isSticky","domNode","getBoundingClientRect","height","pageYOffset","document","documentElement","scrollTop","shouldBeSticky","origin","props","hasUnhandledEvent","hasTouchEvent","nextState","handleEvent","event","componentDidMount","forEach","addEventListener","attachEvent","findDOMNode","getDOMNode","componentWillReceiveProps","componentWillUnmount","removeEventListener","detachEvent","nextStyle","copyStyles","dest","source","rule","nextClassName","hasChanged","setState","render","children","module","exports"],"mappings":"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","file":"bundle.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","var React = require('react');\r\n\r\nvar Sticky = React.createClass({\r\n  /*\r\n   * Using statics to facilitate positional awareness\r\n   * between multiple Sticky instances residing in the\r\n   * DOM at the same time.\r\n   */\r\n  statics: {\r\n    /*\r\n     * Internal variables. Should not be used beyond\r\n     * the scope of other statics methods or testing.\r\n     */\r\n    __frame: null,\r\n    __instances: [],\r\n    /*\r\n     * Adds the supplied Sticky instance to the\r\n     * internal list of mounted Sticky instances,\r\n     * sorted by the .top() value for each instance.\r\n     *\r\n     * If the animation frame loop (or fallback)\r\n     * isn't running, start it now.\r\n     */\r\n    register: function(instance) {\r\n      Sticky.__instances.push(instance);\r\n      Sticky.__instances.sort(function(a, b) {\r\n        if (a.top() > b.top()) return 1;\r\n        if (b.top() > a.top()) return -1;\r\n        return 0;\r\n      });\r\n      if (Sticky.__frame === null) Sticky.resumeLoop();\r\n    },\r\n    /*\r\n     * Remove the supplied Sticky instance from the\r\n     * internal list of mounted Sticky instances.\r\n     *\r\n     * If the animation frame loop (or fallback)\r\n     * is no longer in use, stop it now.\r\n     */\r\n    unregister: function(instance) {\r\n      var index = Sticky.__instances.indexOf(instance);\r\n      if (index > -1) Sticky.__instances.splice(index, 1);\r\n      if (Sticky.__instances.length === 0) Sticky.cancelLoop();\r\n    },\r\n    /*\r\n     * Return every Sticky instance that is\r\n     * positioned above the supplied instance.\r\n     */\r\n    instancesAbove: function(instance) {\r\n      return Sticky.__instances.slice(0, Sticky.__instances.indexOf(instance));\r\n    },\r\n    /*\r\n     * Returns true if the browser environment can support\r\n     * requestAnimationFrame. Otherwise returns false;\r\n     */\r\n    isModernBrowser: function() {\r\n      return window && window.requestAnimationFrame && window.cancelAnimationFrame;\r\n    },\r\n    /*\r\n     * Creates the next frame in the animation loop.\r\n     */\r\n    resumeLoop: function() {\r\n      var nextFrame = Sticky.isModernBrowser() ? requestAnimationFrame : setTimeout;\r\n      Sticky.__frame = nextFrame(Sticky.onFrame, 1000 / 60);\r\n    },\r\n    /*\r\n     * Cancels the animation loop.\r\n     */\r\n    cancelLoop: function() {\r\n      var cancel = Sticky.isModernBrowser() ? cancelAnimationFrame : clearTimeout;\r\n      cancel(Sticky.__frame);\r\n      Sticky.__frame = null;\r\n    },\r\n    /*\r\n     * Loop iteration routine.\r\n     */\r\n    onFrame: function() {\r\n      for (var i = 0; i < Sticky.__instances.length; i++) {\r\n        var sticky = Sticky.__instances[i];\r\n        sticky.handleFrame();\r\n      }\r\n      Sticky.resumeLoop();\r\n    }\r\n  },\r\n  /*\r\n   * Default properties. Self-explanatory...\r\n   */\r\n  getDefaultProps: function() {\r\n    return {\r\n      type: React.DOM.div,\r\n      className: '',\r\n      style: {},\r\n      stickyClass: 'sticky',\r\n      stickyStyle: {\r\n        position: 'fixed',\r\n        top: 0,\r\n        left: 0,\r\n        right: 0,\r\n        zIndex: 1\r\n      },\r\n      topOffset: 0,\r\n      onStickyStateChange: function () {}\r\n    };\r\n  },\r\n  /*\r\n   * Return the list of events this instance\r\n   * should react to.\r\n   */\r\n  getInitialState: function() {\r\n    return {\r\n      events: ['scroll', 'resize', 'touchmove', 'touchend']\r\n    };\r\n  },\r\n  /*\r\n   * Return the distance of the scrollbar from the\r\n   * top of the window plus the total height of all\r\n   * stuck Sticky instances above this one.\r\n   */\r\n  pageOffset: function() {\r\n    var otherStickies = Sticky.instancesAbove(this);\r\n    var otherStickyOffsets = 0;\r\n    for (var i = 0; i < otherStickies.length; i++) {\r\n      var otherSticky = otherStickies[i];\r\n      if (otherSticky.state.isSticky) {\r\n        otherStickyOffsets += otherSticky.domNode.getBoundingClientRect().height;\r\n      }\r\n    }\r\n    return (window.pageYOffset || document.documentElement.scrollTop) + otherStickyOffsets;\r\n  },\r\n  /*\r\n   * Returns the y-coordinate of the top of this element.\r\n   */\r\n  top: function() {\r\n    return this.domNode.getBoundingClientRect().top;\r\n  },\r\n  /*\r\n   * Returns true/false depending on if this should be sticky.\r\n   */\r\n  shouldBeSticky: function() {\r\n    return this.pageOffset() >= this.origin + this.props.topOffset;\r\n  },\r\n  /*\r\n   * Loop iteration for this instance.\r\n   *\r\n   * Should only fire any time there is an event\r\n   * that hasn't been handled. This serves as a\r\n   * throttle for continuous events (i.e. scroll).\r\n   */\r\n  handleFrame: function() {\r\n    if (this.hasUnhandledEvent || this.hasTouchEvent) {\r\n      var shouldBeSticky = this.shouldBeSticky();\r\n      this.nextState(shouldBeSticky);\r\n      this.hasUnhandledEvent = false;\r\n    }\r\n  },\r\n  /*\r\n   * Lightweight event listener for window events.\r\n   *\r\n   * See http://www.html5rocks.com/en/tutorials/speed/animations/\r\n   */\r\n  handleEvent: function(event) {\r\n    switch (event.type) {\r\n      case 'touchmove':\r\n        this.hasTouchEvent = true;\r\n        break;\r\n      case 'touchend':\r\n        this.hasTouchEvent = false;\r\n        break;\r\n      default:\r\n        this.hasUnhandledEvent = true;\r\n    }\r\n  },\r\n  /*\r\n   * Instance was mounted on the page.\r\n   *\r\n   * In order, this function should:\r\n   *  - Register events listeners with window.\r\n   *  - Cache the domNode using React.findDOMNode\r\n   *    or fallback to deprecated getDOMNode().\r\n   *  - Store the initial y-position (origin) of this\r\n   *    instance.\r\n   *  - Register this instance, subscribing to animation\r\n   *    loop.\r\n   */\r\n  componentDidMount: function() {\r\n    this.state.events.forEach(function(type) {\r\n      if (window.addEventListener) {\r\n        window.addEventListener(type, this.handleEvent);\r\n      } else {\r\n        window.attachEvent('on' + type, this.handleEvent);\r\n      }\r\n    }, this);\r\n    this.domNode = React.findDOMNode ? React.findDOMNode(this) : this.getDOMNode();\r\n    this.origin = this.top() + this.pageOffset();\r\n    this.hasUnhandledEvent = true;\r\n    Sticky.register(this);\r\n  },\r\n\r\n  /*\r\n   * Invoked when a component is receiving new prop\r\n   *\r\n   * We need update the this.state.style for correct re-render the component\r\n   */\r\n  componentWillReceiveProps: function(){\r\n    this.hasUnhandledEvent = true;\r\n  },\r\n  /*\r\n   * Instance was removed from the page.\r\n   *\r\n   * Undo everything during mounting.\r\n   */\r\n  componentWillUnmount: function() {\r\n    this.state.events.forEach(function(type) {\r\n      if (window.removeEventListener) {\r\n        window.removeEventListener(type, this.handleEvent);\r\n      } else {\r\n        window.detachEvent('on' + type, this.handleEvent)\r\n      }\r\n    }, this);\r\n    this.domNode = null;\r\n    Sticky.unregister(this);\r\n  },\r\n  /*\r\n   * If sticky, merge this.props.stickyStyle with this.props.style.\r\n   * If not, just return this.props.style.\r\n   */\r\n  nextStyle: function(shouldBeSticky) {\r\n    if (shouldBeSticky) {\r\n      var copyStyles = function(dest, source) {\r\n        for (var rule in source) {\r\n          dest[rule] = source[rule];\r\n        };\r\n        return dest;\r\n      }\r\n      return copyStyles(copyStyles({}, this.props.style), this.props.stickyStyle)\r\n    } else {\r\n      return this.props.style;\r\n    }\r\n  },\r\n  /*\r\n   * If sticky, merge this.props.stickyClass with this.props.className.\r\n   * If not, just return this.props.className.\r\n   */\r\n  nextClassName: function(shouldBeSticky) {\r\n    var className = this.props.className;\r\n    if (shouldBeSticky) {\r\n      className += ' ' + this.props.stickyClass;\r\n    }\r\n    return className;\r\n  },\r\n  /*\r\n   * Transition to the next state.\r\n   *\r\n   * Updates the isSticky, style, and className state\r\n   * variables.\r\n   *\r\n   * If sticky state is different than the previous,\r\n   * fire the onStickyStateChange callback.\r\n   */\r\n  nextState: function(shouldBeSticky) {\r\n    var hasChanged = this.state.isSticky !== shouldBeSticky;\r\n    this.setState({\r\n      isSticky: shouldBeSticky,\r\n      style: this.nextStyle(shouldBeSticky),\r\n      className: this.nextClassName(shouldBeSticky)\r\n    });\r\n    if (hasChanged) this.props.onStickyStateChange(shouldBeSticky);\r\n  },\r\n  /*\r\n   * The special sauce.\r\n   */\r\n  render: function() {\r\n    return this.props.type({\r\n      style: this.state.style,\r\n      className: this.state.className\r\n    }, this.props.children);\r\n  }\r\n});\r\n\r\nmodule.exports = Sticky;\r\n"]}